# 2.1 Installing Express
(1) node js파일명 --> 이 방법으로도 js파일을 실행시킬 수 있다
(2) 이번 프로젝트에서는 package.json으로 실행 해 줄것이다
(3) package.json 안에 main --> 내가 만들고 배포한 package를 다른 사람들이 설치하면 main을 사용한다(이번 프로젝트에서는 필요없음)
(4) package.json 안에 scripts를 만들어 준다
(5) scripts 는 실행하고 싶을 것을 말한다 즉, scripts안에 실행할 것을 적어준다
ex) scripts={
"start": "node index.js" // 이름은 자유롭게 지어줄 수 있다
}
(6) 그 후 npm run start 로 실행시킬 수 있다 // package.json이 존재하는 폴더 한정
(7) npm install express 로 Express 패키지를 다운로드 받는다
(8) node_modules, package-lock.json 파일이 생성도니다
(9) node_modules 에는 npm으로 설치한 모든 패키지가 저장된다
(10) express 는 혼자 작동되지 않기에 다른 패키지가 필요하다
(11) node_modules 안에 express 안에 존재하는 package.json안에 dependencies는 express가 작동되기위해 필요한 패키지들을 나타낸다
(12) express를 설치하는데 의존하고 있는 패키지가 있기 때문에 npm i express를 하면 그것들도 함께 설치된다
(13) npm i express 를 했을 때 npm 이 알아서 dependencies에 express를 추가해준다

#2.2
npm i express
- Created node_modules and package-lock.json and we deleted them
- We're going to install express again but now we are not going to run npm i express
-- We're going to run "npm i" only => We have node_modules and package.json again
--> npm is very smart and it looks at your package.json and finds there is a dependencies entry. And it looks at the dependencies and npm installs them for you
--> package.json is important b/c now it stores the info that our project needs to run
- Very good b/c when you're working on a NodeJS project with a team or changing computers
-- You do not want to upload node_modules to your GitHub
-- node_modules can get super heavy
-- If you want to give to your friend, all you have to do is copy package.json and index.js and that's it. You don't have to copy node_modules
- package-lock: keeps your packages very secure
-- Checks packages haven't been modified and checks with a hash --> really safe
-- Basically locked
-- Important b/c if my project works with package-lock and package.json, when your friend installs express again from the package.json, if you give package.json, package-lock.json, and index.js to your friend, and they run "npm i" only. Then, you're going to be sure that they got the exact same version number on everything.
--> Very useful b/c that means your code is going to run for sure
- We want to be very precise with the version numbers in package-lock.json
-- But we don't have to manage any of this. This is done automatically for us by npm
.gitignore file: Hide your node_modules from your GitHub
- Add "/node_modules"
Reason why you should close package.json
- Some people have trouble when they do "npm i"
- b/c if your package.json is open and you haven't saved and you run "npm i express"
=> npm is going to modify your package.json b/c npm is going to try to add dependencies to pacakge.json
- But b/c you haven't saved, there will be like a conflict on versions
--> Every time you're going to run "npm install", make sure that you close or save your package.json
Remember: Dependencies are what makes your project run
- And you don't have to send your friend the node_modules folder

# 2.3
NodeJS에서 필요한 babel설치
npm install --save-dev @babel/core
npm install @babel/preset-env --save-dev

babel.config.json파일 생성
```
{
"presets": ["@babel/preset-env"]
}
```
https://babeljs.io/setup#installation

@babel/preset-env
@babel/preset-env는 환경에 필요한 구문 변환을 세부적으로 관리할 필요 없이 최신 JavaScript를 사용할 수 있게 해주는 스마트한 preset입니다.
https://babeljs.io/docs/en/babel-preset-env

dependencies = 프로젝트에 필요한것들 다운(필수)
devDependencies = 프로그래머가 더 편하게 코드를 짤수있게 도와주는 보조툴(보조)

#2.4
//nodeJS가 이해하는 코드를 쓰거나 babel을 사용한다.
// babel은 우리가 작성한 최신 자바스크립트를 컴파일 해준다.
// 이 말은 nodeJS가 자바스크립트를 문제없이 이해하도록 변환해준다는 뜻이다.
// pacakge.json은 텍스트 파일인데 devDependencies는 개발자가 필요한 설정인데
dependencies는 무슨 프로젝트를 사용할 지 알려주는데 devDependencies는
 프로젝트를 실행하기 위한 dependencies로 자동차로 따지면 가솔린과 같은 존재이다. 
 devDependencies는 내가 운전을 더 잘하려면 음악이 있어야 하는 것과 비슷하다.
  하나는 개발자에게, 다른 하나는 프로젝트 필요한 것으로 개발자에게 babel이 필요하다. 
  babel이 devDependencies에 들어가면 모든 건 node_modules에 들어가므로 npm install --save-dev @babel/core에서
   --save-dev를 지우고 npm install @babel/core를 사용하면 된다. 다른 곳에 생긴다면 그냥 옮기면 된다.
    babel.config.json configuration file을 사용하면 된다.
     꼭, package.json 파일을 닫거나 저장되어 있는지 확인해야한다.
      babel을 이용해서 최신 문법 코드를 쓸 수 있는데 babel을 설정해 줄 필요가 있다.
       babel.config.json을 만들면 babel이 알아서 이 파일을 찾고 내용을 들여다 본다.
        presets은 babel을 위한 엄청 거대한 플러그인인데 preset-env가 가장 유명하다.
         smart preset을 사용하면 최신 자바스크립트 문법을 사용할 수 있다.
          preset에는 종류가 엄청 많은데, 그 중에 babel/preset-react, babel/preset-typescript 등을 사용할 수 있다.
           preset은 플러그인을 알면 되는데 preset-env는 최신 자바스크립트를 쓸 수 있다.
            babel.config.json 파일을 만들어서 내용을 붙여넣기 하면 되는데 @babel/core와 @bable/preset-env를 설정해야 한다.

#3.0
Make a src folder and all my application (the ones that have code and all the logic: index.js currently) is going to live inside of src
=> Change package.json:
"scripts": {
"dev": "nodemon --exec babel-node src/index.js"
},

The file name doesn't have to be named index.js
- For this, change to server.js and change package.json:
"scripts": {
"dev": "nodemon --exec babel-node src/server.js"
},

=> In server.js:
import express from "express"; // import the package called express from "express"
- NodeJS and npm are so smart that they know that when I do this, I'm looking for express in the node_modules
--> So you don't need to say node_modules/express
- npm and NodeJS are going to search for express in node_modules until they find it and they are going to call index.js
- You don't need to worry node_modules b/c you're not going to write this anywhere in your life

How do we use express:
1) Create an express application
const app = express();
2) Now your application needs to listen
- What is a server?
-- A server is a computer that is always online
-- Most of the time, it doesn't even have a screen or keyboard
-- It's listening to request
--- Request: just a connection
-- You send a message to the server, and the server sends that message to me --> Request
-- Server listens and responses
-- We need to make the server wait for people to ask for stuff
--> `app.listen()`
-- listen() has a callback
--- callback here: the function that will happen when our server starts
--- Before writing the callback, first we need to tell the server what port the server is going to be listening to
---- b/c your computer has many ports
---- port: like a door or window into your computer
---- some ports are open to the Internet

Our server is going to be listening to our port
- The high number ports are always available
app.listen({port number}, callbackFunc); --> we use 4000 as the port number here (not required)

How to go to a server
- When you start a server in your computer, usually that server can be accessed through localhost
http://localhost:4000/

To kill your server and nodemon: ctrl/command + c
- When you kill the server, the localhost refused to connect

import express from "express";

const PORT = 4000;

const app = express();

const handleListening = () =>
console.log(`✅ Server listening on port http://localhost:${PORT} 🚀`);

app.listen(PORT, handleListening);

#3.1
1. Once you create a server, you need to make server respond to user requests.
2. Users request using HTTP protocol. This request is called GET request.
3. When they type in the URL in the address bar and the page loads, they are actually sending a GET request to a server, getting a response and displaying a response on the browser.
I hope this helps and I wish you guys the best! :)

#3.2
1. In order to make a server respond to a GET request from a user's browser, set up .get() that takes in a "home URL" and "eventHandler function" as below:
const handleHome = () => console.log("Somebody is trying to go home.");
app.get("/", handleHome);
2. Having these codes in a server.js (has to placed after express server initiates), it will know how to respond to GET requests from users. However, since EventHandler does not return anything, it will keep the browser loading, waiting for a response from the server.
I hope this helps! God bless you all! :)

#3.3
1. Though setting up .get("URL", "GET handler function") will handle a Get request, it will not respond to a GET reqeust.
2. In order to make a server respond to a user's GET request, you need to modify the EventHandler function into an arrow function. Then, make the response argument .end() or .send() as below:
const handleHome = (req, res) => {
return res.send("I still love you.");
};
3. The first argument inside GET handler function is usually named "req," it takes in a request object.
4. The second argument is usually named "res," and it takes in a response object.
5. res.end() will end the response without returning anything; res.send() will return an input to the user's browser. For this particular example, the user will see a string "I still love you." on their browser when they request for a home ("/") URL page to a server.
I hope this helps! Good luck to you all! :)

#3.4
app.get(path, callback [, callback ...])
지정된 콜백 함수를 사용하여 HTTP GET 요청을 지정된 경로로 라우팅합니다.

Request
req 객체는 HTTP request를 나타내며 요청 query string, parameters, body, HTTP headers 등에 대한 속성을 가지고 있습니다.

Response
res 객체는 Express 앱이 HTTP request를 받을 때 보내는 HTTP response를 나타냅니다.

https://expressjs.com/ko/4x/api.html#express.json

#3.5
-middleware는 reqeust,response 사이에있는 소프트웨어이다.
-모든 controller,handler는 middleware이다.
-middleware에는 controller와같은 2개의 argument외에 한개가 더있다. req, res, 그리고 next
 next();를호출하여 다음 메소드를 실행시키는것이 middleware이다.
 middleware는 절대로 req에대해 response하지않는다.
 ->return은 response한뒤 서버 연결을 끊기때문이다.

#3.7
setup Recap
pacakge.json = scripts안에 실행어를 저장하여 편하게 실행
dependencies,devDependencies = 필요한 툴들을 저장하여
node_modules에 저장하게 도와줌. 실행어는 npm i

devDependencies
 -nodemon => 저장시 변화가있을때 scripts 커맨드를 자동실행
 -bable-node => ES6등 최신코드를 쓰고싶을때 node.js가 이해할수있게 JavaScript를 바꿔줌
  bable.config.json => babe-node를 쓸때 만들어서 필요한 플러그인 정보를 넣음.


#3.8
Server Recap
-Server : request를 listening하고있는 컴퓨터
클라이언트와 서버는 개방된 포트를 통해 request 와 response 를 주고받는다.
 ->브라우저는 서버에게 페이지를 request한다(페이지를 get한다).
 get request에 반응하기위해서는
 app.get("/", handleHome); "/"를 라우터라고 한다.

#3.9
controller Recap
HTTP request 는 어떤 route(url) 에 대한 HTTP Method 요청이고 서버는 그 요청에 대한 response 를 해주어야한다. 여기서 중요한 것이 또 **controller**이다.
# controller
컨트롤러는 전달받은 request를 처리하고 response를 전달하기 위한 콜백함수이다.
request가 왔으면 response해줘야 한다.
controller는 항상 req,res를 아규먼트로 가진다.
req,res에는 많은 메소드가 있다.
 ->res.send()나 res.end() 등으로 respond해줘야한다.

#3.10
middleware
 request와 response의 중간에 있는 소프트웨어이다.
 app.get("/",middleware, handleHome)
 미들웨어는 request 오브젝트와, response 오브젝트 말고도 next 파라미터를 갖는다.
 next 파라미터는 다음으로 request 를 처리할 콜백함수를 담고있다.
미들웨어를 글로벌하게 사용하는법
app.use(미들웨어1,미들웨어2...)를 만들어 get("/", ...)보다 위에 둔다.

#3.11
morgan
 -morgan 패키지는 node.js 서버로 구성된 웹 환경에서
  HTTP request 로그를 관리하기 위한 미들웨어이다.
npm i morgan으로 설치한후
import morgan from "morgan"으로 부른후 사용한다.
 ->사용법은 app.use(morgan("dev..")) 등으로
 morgan()이 미들웨어를 return해준다. 아규먼트는 5종류있다.

#4.0
라우터
 라우터는 url이 어떻게 시작하는지에 따라 나누는 방법
 라우터는 작업중인 주제를 기반으로 URL을 그룹화한다
 /users/edit -> Edit user
 /videos/watch -> Watch Video

#4.1
 라우터의 그룹화 규칙에 따르면 로그인페이지는 
 /users/login이어야 한다. 유저가 로그인하기때문이다.
 하지만 때때로 편의성을위해 예외를 두기도한다.
 /login이 더 깔끔하기 때문이다.

** 유저의 req-> 서버 res 흐름
유저가 /videos로 시작하는 url에 들어가면
express는 video라우터에 들어가서, url의 나머지주소를 찾는다.

#4.2
server.js에 라우터를 다 모아놓으면 보기안좋으니 정리한다.
global,user,video라우터 각 3개의 폴더로 나눈다.
그럼 server.js에서 각 라우터를 못찾을텐데 각각을 import해줘야한다.
 프로젝트에 있는 모든 파일은 분리된 모듈이다.
 다른 파일에서 쓸때는 그 파일에서 export, 쓸파일에서 import해야한다.

#4.3
 라우터와 컨트롤러를 같은파일에 쓰는것은 좋지않다.
 컨트롤러는 많은 데이터를 가져와 처리할것이고 양이 방대해질것이기 때문
 따라서 컨트롤러 폴더/파일을 따로 만들어 관리하자.

export
 -> default export한것을 import할때 지정하는 이름은 같지않아도 됀다
 하지만 개별을 export할때는 반드시 서로 같아야 한다.
 ->중괄호 열고 { edit, remove, ...}등 불러올것을 똑같이 적어넣어 오브젝트화시킨다.
 ** 경로지정 규칙
 ../ 지금있는 폴더에서 벗어남
 ./ 지금있는 장소

 #4.7
 URL parameters
 videoRouter.get("/:id", see);
 /:id에서 :은 뒤에오는 id가 파라메터(변수)라고 express에게 알려준다.
 그 파라메터는 컨트롤러에서 req.params.id로 유저의 리퀘스트중 파라메터값이 무엇인지 확인가능.

 **비디오 라우터에서
  videoRouter.get("/upload", upload);
  videoRouter.get("/:id", see);
  videoRouter.get("/:id/edit", edit);
  처럼 upload를 맨위로 올리는 이유가 있다.
  express는 위에서부터 아래로 체크하기때문에, 만약 
  videoRouter.get("/:id", see);
  videoRouter.get("/upload", upload);
  videoRouter.get("/:id/edit", edit);
  이순서이고, 유저가 videos/upload로 request를 보내면
  express는 :id를 먼저보고 /upload를 파라메터로 취급하게됀다.
  =>이것의 해결을위해 express 정규식을 사용한다.
  정규식을 사용하여 파라메터에 숫자만 올수있게 하는것이다.

#4.8
URL parameters 정규식
  Routing
  https://expressjs.com/ko/guide/routing.html
  정규표현식 테스트 사이트
  https://www.regexpal.com
  정규식 표현 정리글
  https://kasterra.github.io/regex1-the-basic-operation/

  \w+: 모든 문자, 숫자 선택
  \d+: 모든 숫자 선택

#5.1

**
pug사용에대한 의문
res.sendFile(__dirname, 'potato.html') 같이 html 파일을 바로 렌더링 할 수 있긴 합니다.
하지만 request를 통해 각종 변수를 전달하지 못하기 때문에 미리 정해둔 화면 밖에는 보여줄 수가 없고,
header 나 footer 등을 따로 partial로 만들어 관리하고 모든 파일에 첨부한다든지 할 수 있기 때문에 pug를 쓰는 것입니다.
또한 pug외에도 ejs등 다른 template engine도 있습니다. 저는 써 본 것 중에서는 pug가 제일 깔끔하고 좋은 것 같네요.
그리고 아예 react등의 framework를 사용하시면 템플릿 엔진 없이 view부분을 만드실 수 있습니다.

pug사용
send에 html을 보내기는 힘들다.
pug를 사용하면 편하다.
 1) 깔끔한 html작성을 도와준다(닫지않아도됀다)
 2) html에 자바스클비트 코드를 포함시킬수있다.
 3) 반복이 있으면 partials폴더를 만들어 그곳에 반복파일을 만들고
 html내에서 include 시키면됀다
따라서 그걸 도와주는 pug를 설치한다 npm i pug
->server.js에서 app.set("view engine", "pug")을 통해
view엔진이 pug라는걸 express에 알려준다.
**
헤더에서 Express를 없애는 방법:
app.disable('x-powered-by');
->views폴더에 pug파일을 만든다.

**
디폴트로 express는 cwd + /views에서 pug 파일을 찾는다.
cwd(current working directory)는 node.js를 실행하는 pacakge.json이 있는 디렉토리이므로
현재 프로젝트는wetube/가 cwd이다.
현 프로젝트에 views폴더는 wetube/src/안에 있기때문에 디폴트 view경로를 바꾼다.
app.set("views", process.cwd() + "/src/views")으로 경로를 바꿀수있다.

#5.3
block기능
 상속을 해줄 base.pug파일에서 block을 만들어놓으면
 상속받는 파일에서 block안 내용을 채울수 있다.
include기능
 base.pug파일에서 include로 내용을추가해놓으면 모든 상속받는 파일에서
 그 내용이 적용됀다.
Pug는 템플릿 상속을 지원합니다. 템플릿 상속은 block과 extends키워드를 통해 사용합니다.
템플릿의 block에는 하위 템플릿을 대체할 수 있습니다.
**
ENOENT: no such file or directory, open '/home/ndm02002/wetube/src/views/base.pug'
base 파일을 view 아래에 놓아야 됨 ㅠ

#5.4
변수variables 사용
컨트롤러에서 변수를 같이 보내면, 그 변수를 pug에서도 사용할수있다.
컨트롤러 => res.render("home", { pageTitle: "Home" });
base.pug => title #{pageTitle} | Wetube

#5.5
pug recap
1) 파이썬처럼 깔끔한 코드를 쓸수있다.
  태그를 닫는것 x
  모두 탭과 띄어쓰기로 구분됀다.
2) express가 랜더링 할수있다.
  app.set으로 어디서찾는지 설정해준뒤
  res.render("pug파일명)
3) include : 상속받는 모든파일에서 공통적으로 나타낼때

4) base.pug 기본구조를 만들어 다른파일에서 똑같이 상속받을때
block기능으로 상속받는 파일들이 블록 내용을 채워넣을수있다.

5) variable
자바스크립트 코드를 #{}로 쓸수있다.
이때 변수도 쓸수있는데, 컨트롤러에서 랜더링할때 변수를 같이 보내주면
그 변수를 pug파일에서 사용가능하다.

#5.6
MVP Styles
모든 html element를 이쁘게 만들어주는
link(rel="stylesheet" href="https://unpkg.com/mvp.css")를 헤드에 추가

#5.7
pug에서 변수를 대입할때 2가지방법
title #{pageTitle} Wetube
title = pageTitle =>한개의 변수외에 텍스트가없을때.

pug에서도 조건문을 쓸수있다 if/else
if 조건
  실행식
else
  실행식

#5.8
Iteration
  elements의 list를 보여주는것
Iteration (반복)

Pug는 each와 while라는 두 가지 기본 반복 방법을 지원합니다.
```
ul
each val(아무이름가능) in [1, 2, 3, 4, 5](컨트롤러에서 보내준 변수명이랑 같아야)
li= val
```

**
배열이나 객체에 반복할 값이 없으면 실행될 else 블록을 추가할 수도 있습니다.
```
- var values = [];
ul
each val in values
li= val
else
li There are no values
```
https://pugjs.org/language/iteration.html

#5.9
mixin
=> partial과 유사한 데이터를 받을수있는 미리 만들어진 HTML block이다.
사용
1)mixins폴더에 mixin파일명.pug를 만들어주고 내용을 작성한다.
2)mixin이 필요한 곳에서 include mixins/video(파일명)으로 인클루드 해준다.
3)사용이 필요한 위치에서 +파일명(변수명) 넣어준다
    each potato in videos
        +video(potato)
    else
        li Sorry nothing found.
자세히는
https://pugjs.org/language/mixins.html

#5.10
Iteration mixin recap
Iteration은 array의 모든 element에 대해 특정 행동을 할때 씀
mixin은 partial과 유사하게 반복해서 쓰지만
데이터도 받아 쓸수있는것이 다르다.

#6.0
POST

pug에서 변수variable을 쓰는방법은 =, #{} 두개가 있다고
위에서 배웠지만 attribute에는 쓸수없다.
attribute에서 변수를 쓰는방법은 `${}` 혹은 + video.id 로 두가지이다.

**ES6
const { id } = req.params;
const id = req.params.id;

#6.1

absoulte(/) relative URL 절대 상대
현재 경로가 localhost:4000/video/edit인데
a(href="/potato")이면 =>localhost:4000/potato로(absoulte)
a(href="potato")이면 =>localhost:4000/video/potato로(relative)

#6.2
POST
form(action="")의 action에는 submit을 누르면 데이터가 가게될곳을 적는다.
디폴트 전송방식은 get이다(method="GET") POST로 바꿔주면 POST전송이됀다.
POST를 쓰려면 라우터에서도 POST로 받아줘야한다.

method는 form과 back end 사이의 정보 전송 방식이다.
전송하는 데이터로 backend에서 database의 정보를 수정,추가,삭제..등을 할거면
POST로 전송해야한다.

#6.3
get - 접근
post - 전송
redirect - 다시보내다
parameter - 매개변수
express는 form으로 보낸 데이터를 읽지못함

**
req.body
req.body에는 form을 통해 submit된 데이터의 키-값 쌍을 포함합니다.
기본적으로는 undefined이며 express.json() 또는 express.urlencoded()와 같은 바디 파싱 미들웨어를 사용할 때 값을 받아옵니다.

```
// 애플리케이션/json 파싱
app.use(express.json());
// application/x-www-form-urlencoded파싱 (form데이터 파싱)
app.use(express.urlencoded({ extended: true }));
```
https://expressjs.com/ko/api.html#req.body

express.urlencoded([options])
Express에 내장된 미들웨어 기능입니다. urlencoded 페이로드로 들어오는 요청을 구문 분석하고 바디 파서를 기반으로 합니다.
https://expressjs.com/ko/api.html#express.urlencoded


POST로 보낸 데이터를 사용하려면 req.body로 사용가능하다.
하지만 express는 아직 이걸 이해못한다.
express app이 form의 value를 이해하려면 세팅이필요하다.
server.js에 다음을 추가한다.
app.use(express.urlencoded({ extended: true }));
 => 라우터를 사용하기전에 적용이 돼야한다.

#6.4
POST recap
컨트롤러에서 쓰는 req.params는
 라우터에서 보낸 /:id(//d+)를 가리킨다.
req.body는 pug에서 보낸 form에있는 value의 JavaScript representation이다.
 => 이걸 이용하기위해 server.js에 설정을 해줘야한다.
 => form안의 input에 name을 설정해줘야 req.body안의 데이터를 쓸수있다.
**
GET으로보낸 데이터는 req.query.inputName으로 사용할수있다!
