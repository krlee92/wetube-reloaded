# 2.1 Installing Express
(1) node js파일명 --> 이 방법으로도 js파일을 실행시킬 수 있다
(2) 이번 프로젝트에서는 package.json으로 실행 해 줄것이다
(3) package.json 안에 main --> 내가 만들고 배포한 package를 다른 사람들이 설치하면 main을 사용한다(이번 프로젝트에서는 필요없음)
(4) package.json 안에 scripts를 만들어 준다
(5) scripts 는 실행하고 싶을 것을 말한다 즉, scripts안에 실행할 것을 적어준다
ex) scripts={
"start": "node index.js" // 이름은 자유롭게 지어줄 수 있다
}
(6) 그 후 npm run start 로 실행시킬 수 있다 // package.json이 존재하는 폴더 한정
(7) npm install express 로 Express 패키지를 다운로드 받는다
(8) node_modules, package-lock.json 파일이 생성도니다
(9) node_modules 에는 npm으로 설치한 모든 패키지가 저장된다
(10) express 는 혼자 작동되지 않기에 다른 패키지가 필요하다
(11) node_modules 안에 express 안에 존재하는 package.json안에 dependencies는 express가 작동되기위해 필요한 패키지들을 나타낸다
(12) express를 설치하는데 의존하고 있는 패키지가 있기 때문에 npm i express를 하면 그것들도 함께 설치된다
(13) npm i express 를 했을 때 npm 이 알아서 dependencies에 express를 추가해준다

#2.2
npm i express
- Created node_modules and package-lock.json and we deleted them
- We're going to install express again but now we are not going to run npm i express
-- We're going to run "npm i" only => We have node_modules and package.json again
--> npm is very smart and it looks at your package.json and finds there is a dependencies entry. And it looks at the dependencies and npm installs them for you
--> package.json is important b/c now it stores the info that our project needs to run
- Very good b/c when you're working on a NodeJS project with a team or changing computers
-- You do not want to upload node_modules to your GitHub
-- node_modules can get super heavy
-- If you want to give to your friend, all you have to do is copy package.json and index.js and that's it. You don't have to copy node_modules
- package-lock: keeps your packages very secure
-- Checks packages haven't been modified and checks with a hash --> really safe
-- Basically locked
-- Important b/c if my project works with package-lock and package.json, when your friend installs express again from the package.json, if you give package.json, package-lock.json, and index.js to your friend, and they run "npm i" only. Then, you're going to be sure that they got the exact same version number on everything.
--> Very useful b/c that means your code is going to run for sure
- We want to be very precise with the version numbers in package-lock.json
-- But we don't have to manage any of this. This is done automatically for us by npm
.gitignore file: Hide your node_modules from your GitHub
- Add "/node_modules"
Reason why you should close package.json
- Some people have trouble when they do "npm i"
- b/c if your package.json is open and you haven't saved and you run "npm i express"
=> npm is going to modify your package.json b/c npm is going to try to add dependencies to pacakge.json
- But b/c you haven't saved, there will be like a conflict on versions
--> Every time you're going to run "npm install", make sure that you close or save your package.json
Remember: Dependencies are what makes your project run
- And you don't have to send your friend the node_modules folder

# 2.3
NodeJS에서 필요한 babel설치
npm install --save-dev @babel/core
npm install @babel/preset-env --save-dev

babel.config.json파일 생성
```
{
"presets": ["@babel/preset-env"]
}
```
https://babeljs.io/setup#installation

@babel/preset-env
@babel/preset-env는 환경에 필요한 구문 변환을 세부적으로 관리할 필요 없이 최신 JavaScript를 사용할 수 있게 해주는 스마트한 preset입니다.
https://babeljs.io/docs/en/babel-preset-env

dependencies = 프로젝트에 필요한것들 다운(필수)
devDependencies = 프로그래머가 더 편하게 코드를 짤수있게 도와주는 보조툴(보조)

#2.4
//nodeJS가 이해하는 코드를 쓰거나 babel을 사용한다.
// babel은 우리가 작성한 최신 자바스크립트를 컴파일 해준다.
// 이 말은 nodeJS가 자바스크립트를 문제없이 이해하도록 변환해준다는 뜻이다.
// pacakge.json은 텍스트 파일인데 devDependencies는 개발자가 필요한 설정인데
dependencies는 무슨 프로젝트를 사용할 지 알려주는데 devDependencies는
 프로젝트를 실행하기 위한 dependencies로 자동차로 따지면 가솔린과 같은 존재이다. 
 devDependencies는 내가 운전을 더 잘하려면 음악이 있어야 하는 것과 비슷하다.
  하나는 개발자에게, 다른 하나는 프로젝트 필요한 것으로 개발자에게 babel이 필요하다. 
  babel이 devDependencies에 들어가면 모든 건 node_modules에 들어가므로 npm install --save-dev @babel/core에서
   --save-dev를 지우고 npm install @babel/core를 사용하면 된다. 다른 곳에 생긴다면 그냥 옮기면 된다.
    babel.config.json configuration file을 사용하면 된다.
     꼭, package.json 파일을 닫거나 저장되어 있는지 확인해야한다.
      babel을 이용해서 최신 문법 코드를 쓸 수 있는데 babel을 설정해 줄 필요가 있다.
       babel.config.json을 만들면 babel이 알아서 이 파일을 찾고 내용을 들여다 본다.
        presets은 babel을 위한 엄청 거대한 플러그인인데 preset-env가 가장 유명하다.
         smart preset을 사용하면 최신 자바스크립트 문법을 사용할 수 있다.
          preset에는 종류가 엄청 많은데, 그 중에 babel/preset-react, babel/preset-typescript 등을 사용할 수 있다.
           preset은 플러그인을 알면 되는데 preset-env는 최신 자바스크립트를 쓸 수 있다.
            babel.config.json 파일을 만들어서 내용을 붙여넣기 하면 되는데 @babel/core와 @bable/preset-env를 설정해야 한다.

#3.0
Make a src folder and all my application (the ones that have code and all the logic: index.js currently) is going to live inside of src
=> Change package.json:
"scripts": {
"dev": "nodemon --exec babel-node src/index.js"
},

The file name doesn't have to be named index.js
- For this, change to server.js and change package.json:
"scripts": {
"dev": "nodemon --exec babel-node src/server.js"
},

=> In server.js:
import express from "express"; // import the package called express from "express"
- NodeJS and npm are so smart that they know that when I do this, I'm looking for express in the node_modules
--> So you don't need to say node_modules/express
- npm and NodeJS are going to search for express in node_modules until they find it and they are going to call index.js
- You don't need to worry node_modules b/c you're not going to write this anywhere in your life

How do we use express:
1) Create an express application
const app = express();
2) Now your application needs to listen
- What is a server?
-- A server is a computer that is always online
-- Most of the time, it doesn't even have a screen or keyboard
-- It's listening to request
--- Request: just a connection
-- You send a message to the server, and the server sends that message to me --> Request
-- Server listens and responses
-- We need to make the server wait for people to ask for stuff
--> `app.listen()`
-- listen() has a callback
--- callback here: the function that will happen when our server starts
--- Before writing the callback, first we need to tell the server what port the server is going to be listening to
---- b/c your computer has many ports
---- port: like a door or window into your computer
---- some ports are open to the Internet

Our server is going to be listening to our port
- The high number ports are always available
app.listen({port number}, callbackFunc); --> we use 4000 as the port number here (not required)

How to go to a server
- When you start a server in your computer, usually that server can be accessed through localhost
http://localhost:4000/

To kill your server and nodemon: ctrl/command + c
- When you kill the server, the localhost refused to connect

import express from "express";

const PORT = 4000;

const app = express();

const handleListening = () =>
console.log(`✅ Server listening on port http://localhost:${PORT} 🚀`);

app.listen(PORT, handleListening);

#3.1
1. Once you create a server, you need to make server respond to user requests.
2. Users request using HTTP protocol. This request is called GET request.
3. When they type in the URL in the address bar and the page loads, they are actually sending a GET request to a server, getting a response and displaying a response on the browser.
I hope this helps and I wish you guys the best! :)

#3.2
1. In order to make a server respond to a GET request from a user's browser, set up .get() that takes in a "home URL" and "eventHandler function" as below:
const handleHome = () => console.log("Somebody is trying to go home.");
app.get("/", handleHome);
2. Having these codes in a server.js (has to placed after express server initiates), it will know how to respond to GET requests from users. However, since EventHandler does not return anything, it will keep the browser loading, waiting for a response from the server.
I hope this helps! God bless you all! :)

#3.3
1. Though setting up .get("URL", "GET handler function") will handle a Get request, it will not respond to a GET reqeust.
2. In order to make a server respond to a user's GET request, you need to modify the EventHandler function into an arrow function. Then, make the response argument .end() or .send() as below:
const handleHome = (req, res) => {
return res.send("I still love you.");
};
3. The first argument inside GET handler function is usually named "req," it takes in a request object.
4. The second argument is usually named "res," and it takes in a response object.
5. res.end() will end the response without returning anything; res.send() will return an input to the user's browser. For this particular example, the user will see a string "I still love you." on their browser when they request for a home ("/") URL page to a server.
I hope this helps! Good luck to you all! :)

#3.4
app.get(path, callback [, callback ...])
지정된 콜백 함수를 사용하여 HTTP GET 요청을 지정된 경로로 라우팅합니다.

Request
req 객체는 HTTP request를 나타내며 요청 query string, parameters, body, HTTP headers 등에 대한 속성을 가지고 있습니다.

Response
res 객체는 Express 앱이 HTTP request를 받을 때 보내는 HTTP response를 나타냅니다.

https://expressjs.com/ko/4x/api.html#express.json

#3.5
-middleware는 reqeust,response 사이에있는 소프트웨어이다.
-모든 controller,handler는 middleware이다.
-middleware에는 controller와같은 2개의 argument외에 한개가 더있다. req, res, 그리고 next
 next();를호출하여 다음 메소드를 실행시키는것이 middleware이다.
 middleware는 절대로 req에대해 response하지않는다.
 ->return은 response한뒤 서버 연결을 끊기때문이다.

#3.7
setup Recap
pacakge.json = scripts안에 실행어를 저장하여 편하게 실행
dependencies,devDependencies = 필요한 툴들을 저장하여
node_modules에 저장하게 도와줌. 실행어는 npm i

devDependencies
 -nodemon => 저장시 변화가있을때 scripts 커맨드를 자동실행
 -bable-node => ES6등 최신코드를 쓰고싶을때 node.js가 이해할수있게 JavaScript를 바꿔줌
  bable.config.json => babe-node를 쓸때 만들어서 필요한 플러그인 정보를 넣음.


#3.8
Server Recap
-Server : request를 listening하고있는 컴퓨터
클라이언트와 서버는 개방된 포트를 통해 request 와 response 를 주고받는다.
 ->브라우저는 서버에게 페이지를 request한다(페이지를 get한다).
 get request에 반응하기위해서는
 app.get("/", handleHome); "/"를 라우터라고 한다.

#3.9
controller Recap
HTTP request 는 어떤 route(url) 에 대한 HTTP Method 요청이고 서버는 그 요청에 대한 response 를 해주어야한다. 여기서 중요한 것이 또 **controller**이다.
# controller
컨트롤러는 전달받은 request를 처리하고 response를 전달하기 위한 콜백함수이다.
request가 왔으면 response해줘야 한다.
controller는 항상 req,res를 아규먼트로 가진다.
req,res에는 많은 메소드가 있다.
 ->res.send()나 res.end() 등으로 respond해줘야한다.

#3.10
middleware
 request와 response의 중간에 있는 소프트웨어이다.
 app.get("/",middleware, handleHome)
 미들웨어는 request 오브젝트와, response 오브젝트 말고도 next 파라미터를 갖는다.
 next 파라미터는 다음으로 request 를 처리할 콜백함수를 담고있다.
미들웨어를 글로벌하게 사용하는법
app.use(미들웨어1,미들웨어2...)를 만들어 get("/", ...)보다 위에 둔다.

#3.11
morgan
 -morgan 패키지는 node.js 서버로 구성된 웹 환경에서
  HTTP request 로그를 관리하기 위한 미들웨어이다.
npm i morgan으로 설치한후
import morgan from "morgan"으로 부른후 사용한다.
 ->사용법은 app.use(morgan("dev..")) 등으로
 morgan()이 미들웨어를 return해준다. 아규먼트는 5종류있다.

#4.0
라우터
 라우터는 url이 어떻게 시작하는지에 따라 나누는 방법
 라우터는 작업중인 주제를 기반으로 URL을 그룹화한다
 /users/edit -> Edit user
 /videos/watch -> Watch Video

#4.1
 라우터의 그룹화 규칙에 따르면 로그인페이지는 
 /users/login이어야 한다. 유저가 로그인하기때문이다.
 하지만 때때로 편의성을위해 예외를 두기도한다.
 /login이 더 깔끔하기 때문이다.

** 유저의 req-> 서버 res 흐름
유저가 /videos로 시작하는 url에 들어가면
express는 video라우터에 들어가서, url의 나머지주소를 찾는다.

#4.2
server.js에 라우터를 다 모아놓으면 보기안좋으니 정리한다.
global,user,video라우터 각 3개의 폴더로 나눈다.
그럼 server.js에서 각 라우터를 못찾을텐데 각각을 import해줘야한다.
 프로젝트에 있는 모든 파일은 분리된 모듈이다.
 다른 파일에서 쓸때는 그 파일에서 export, 쓸파일에서 import해야한다.

#4.3
 라우터와 컨트롤러를 같은파일에 쓰는것은 좋지않다.
 컨트롤러는 많은 데이터를 가져와 처리할것이고 양이 방대해질것이기 때문
 따라서 컨트롤러 폴더/파일을 따로 만들어 관리하자.

export
 -> default export한것을 import할때 지정하는 이름은 같지않아도 됀다
 하지만 개별을 export할때는 반드시 서로 같아야 한다.
 ->중괄호 열고 { edit, remove, ...}등 불러올것을 똑같이 적어넣어 오브젝트화시킨다.
 ** 경로지정 규칙
 ../ 지금있는 폴더에서 벗어남
 ./ 지금있는 장소

 #4.7
 URL parameters
 videoRouter.get("/:id", see);
 /:id에서 :은 뒤에오는 id가 파라메터(변수)라고 express에게 알려준다.
 그 파라메터는 컨트롤러에서 req.params.id로 유저의 리퀘스트중 파라메터값이 무엇인지 확인가능.

 **비디오 라우터에서
  videoRouter.get("/upload", upload);
  videoRouter.get("/:id", see);
  videoRouter.get("/:id/edit", edit);
  처럼 upload를 맨위로 올리는 이유가 있다.
  express는 위에서부터 아래로 체크하기때문에, 만약 
  videoRouter.get("/:id", see);
  videoRouter.get("/upload", upload);
  videoRouter.get("/:id/edit", edit);
  이순서이고, 유저가 videos/upload로 request를 보내면
  express는 :id를 먼저보고 /upload를 파라메터로 취급하게됀다.
  =>이것의 해결을위해 express 정규식을 사용한다.
  정규식을 사용하여 파라메터에 숫자만 올수있게 하는것이다.

#4.8
URL parameters 정규식
  Routing
  https://expressjs.com/ko/guide/routing.html
  정규표현식 테스트 사이트
  https://www.regexpal.com
  정규식 표현 정리글
  https://kasterra.github.io/regex1-the-basic-operation/

  \w+: 모든 문자, 숫자 선택
  \d+: 모든 숫자 선택

#5.1

**
pug사용에대한 의문
res.sendFile(__dirname, 'potato.html') 같이 html 파일을 바로 렌더링 할 수 있긴 합니다.
하지만 request를 통해 각종 변수를 전달하지 못하기 때문에 미리 정해둔 화면 밖에는 보여줄 수가 없고,
header 나 footer 등을 따로 partial로 만들어 관리하고 모든 파일에 첨부한다든지 할 수 있기 때문에 pug를 쓰는 것입니다.
또한 pug외에도 ejs등 다른 template engine도 있습니다. 저는 써 본 것 중에서는 pug가 제일 깔끔하고 좋은 것 같네요.
그리고 아예 react등의 framework를 사용하시면 템플릿 엔진 없이 view부분을 만드실 수 있습니다.

pug사용
send에 html을 보내기는 힘들다.
pug를 사용하면 편하다.
 1) 깔끔한 html작성을 도와준다(닫지않아도됀다)
 2) html에 자바스클비트 코드를 포함시킬수있다.
 3) 반복이 있으면 partials폴더를 만들어 그곳에 반복파일을 만들고
 html내에서 include 시키면됀다
따라서 그걸 도와주는 pug를 설치한다 npm i pug
->server.js에서 app.set("view engine", "pug")을 통해
view엔진이 pug라는걸 express에 알려준다.
**
헤더에서 Express를 없애는 방법:
app.disable('x-powered-by');
->views폴더에 pug파일을 만든다.

**
디폴트로 express는 cwd + /views에서 pug 파일을 찾는다.
cwd(current working directory)는 node.js를 실행하는 pacakge.json이 있는 디렉토리이므로
현재 프로젝트는wetube/가 cwd이다.
현 프로젝트에 views폴더는 wetube/src/안에 있기때문에 디폴트 view경로를 바꾼다.
app.set("views", process.cwd() + "/src/views")으로 경로를 바꿀수있다.

#5.3
block기능
 상속을 해줄 base.pug파일에서 block을 만들어놓으면
 상속받는 파일에서 block안 내용을 채울수 있다.
include기능
 base.pug파일에서 include로 내용을추가해놓으면 모든 상속받는 파일에서
 그 내용이 적용됀다.
Pug는 템플릿 상속을 지원합니다. 템플릿 상속은 block과 extends키워드를 통해 사용합니다.
템플릿의 block에는 하위 템플릿을 대체할 수 있습니다.
**
ENOENT: no such file or directory, open '/home/ndm02002/wetube/src/views/base.pug'
base 파일을 view 아래에 놓아야 됨 ㅠ

#5.4
변수variables 사용
컨트롤러에서 변수를 같이 보내면, 그 변수를 pug에서도 사용할수있다.
컨트롤러 => res.render("home", { pageTitle: "Home" });
base.pug => title #{pageTitle} | Wetube

#5.5
pug recap
1) 파이썬처럼 깔끔한 코드를 쓸수있다.
  태그를 닫는것 x
  모두 탭과 띄어쓰기로 구분됀다.
2) express가 랜더링 할수있다.
  app.set으로 어디서찾는지 설정해준뒤
  res.render("pug파일명)
3) include : 상속받는 모든파일에서 공통적으로 나타낼때

4) base.pug 기본구조를 만들어 다른파일에서 똑같이 상속받을때
block기능으로 상속받는 파일들이 블록 내용을 채워넣을수있다.

5) variable
자바스크립트 코드를 #{}로 쓸수있다.
이때 변수도 쓸수있는데, 컨트롤러에서 랜더링할때 변수를 같이 보내주면
그 변수를 pug파일에서 사용가능하다.

#5.6
MVP Styles
모든 html element를 이쁘게 만들어주는
link(rel="stylesheet" href="https://unpkg.com/mvp.css")를 헤드에 추가

#5.7
pug에서 변수를 대입할때 2가지방법
title #{pageTitle} Wetube
title = pageTitle =>한개의 변수외에 텍스트가없을때.

pug에서도 조건문을 쓸수있다 if/else
if 조건
  실행식
else
  실행식

#5.8
Iteration
  elements의 list를 보여주는것
Iteration (반복)

Pug는 each와 while라는 두 가지 기본 반복 방법을 지원합니다.
```
ul
each val(아무이름가능) in [1, 2, 3, 4, 5](컨트롤러에서 보내준 변수명이랑 같아야)
li= val
```

**
배열이나 객체에 반복할 값이 없으면 실행될 else 블록을 추가할 수도 있습니다.
```
- var values = [];
ul
each val in values
li= val
else
li There are no values
```
https://pugjs.org/language/iteration.html

#5.9
mixin
=> partial과 유사한 데이터를 받을수있는 미리 만들어진 HTML block이다.
사용
1)mixins폴더에 mixin파일명.pug를 만들어주고 내용을 작성한다.
2)mixin이 필요한 곳에서 include mixins/video(파일명)으로 인클루드 해준다.
3)사용이 필요한 위치에서 +파일명(변수명) 넣어준다
    each potato in videos
        +video(potato)
    else
        li Sorry nothing found.
자세히는
https://pugjs.org/language/mixins.html

#5.10
Iteration mixin recap
Iteration은 array의 모든 element에 대해 특정 행동을 할때 씀
mixin은 partial과 유사하게 반복해서 쓰지만
데이터도 받아 쓸수있는것이 다르다.

#6.0
POST

pug에서 변수variable을 쓰는방법은 =, #{} 두개가 있다고
위에서 배웠지만 attribute에는 쓸수없다.
attribute에서 변수를 쓰는방법은 `${}` 혹은 + video.id 로 두가지이다.

**ES6
const { id } = req.params;
const id = req.params.id;

#6.1

absoulte(/) relative URL 절대 상대
현재 경로가 localhost:4000/video/edit인데
a(href="/potato")이면 =>localhost:4000/potato로(absoulte)
a(href="potato")이면 =>localhost:4000/video/potato로(relative)

#6.2
POST
form(action="")의 action에는 submit을 누르면 데이터가 가게될곳을 적는다.
디폴트 전송방식은 get이다(method="GET") POST로 바꿔주면 POST전송이됀다.
POST를 쓰려면 라우터에서도 POST로 받아줘야한다.

method는 form과 back end 사이의 정보 전송 방식이다.
전송하는 데이터로 backend에서 database의 정보를 수정,추가,삭제..등을 할거면
POST로 전송해야한다.

#6.3
get - 접근
post - 전송
redirect - 다시보내다
parameter - 매개변수
express는 form으로 보낸 데이터를 읽지못함

**
req.body
req.body에는 form을 통해 submit된 데이터의 키-값 쌍을 포함합니다.
기본적으로는 undefined이며 express.json() 또는 express.urlencoded()와 같은 바디 파싱 미들웨어를 사용할 때 값을 받아옵니다.

```
// 애플리케이션/json 파싱
app.use(express.json());
// application/x-www-form-urlencoded파싱 (form데이터 파싱)
app.use(express.urlencoded({ extended: true }));
```
https://expressjs.com/ko/api.html#req.body

express.urlencoded([options])
Express에 내장된 미들웨어 기능입니다. urlencoded 페이로드로 들어오는 요청을 구문 분석하고 바디 파서를 기반으로 합니다.
https://expressjs.com/ko/api.html#express.urlencoded


POST로 보낸 데이터를 사용하려면 req.body로 사용가능하다.
하지만 express는 아직 이걸 이해못한다.
express app이 form의 value를 이해하려면 세팅이필요하다.
server.js에 다음을 추가한다.
app.use(express.urlencoded({ extended: true }));
 => 라우터를 사용하기전에 적용이 돼야한다.

#6.4
POST recap
컨트롤러에서 쓰는 req.params는
 라우터에서 보낸 /:id(//d+)를 가리킨다.
req.body는 pug에서 보낸 form에있는 value의 JavaScript representation이다.
 => 이걸 이용하기위해 server.js에 설정을 해줘야한다.
 => form안의 input에 name을 설정해줘야 req.body안의 데이터를 쓸수있다.
**
GET으로보낸 데이터는 req.query.inputName으로 사용할수있다!

#6.8
mongoose
  자바스크립트 코드로 mongodb를 쓸수있게 해준다
  1)npm i mongoose로 설치
  2)db.js파일에서 import mongoose from "mongoose"
  3)mongoose.connect("mongodb://127.0.0.1:27017/db명");
    =>url주소는 cmd에서 mongo 커맨드 실행시 나오는 주소
그외설정
  const db = mongoose.connection;

  const handleOpen = () => console.log("✅ Connected to DB");
  const handleError = (error) => console.log("❌ DB Error", error);

  db.on("error", handleError);
  db.once("open", handleOpen);
  on => 이벤트발생시 몇번이고 반복함
  once => 이벤트발생시 한번만실행함

#6.9
Video model
 모델 이름은 대문자로 시작한다. Video.js 이게 관습이다.

스키마:물리적인 장치로부터 논리적인 데이터 베이스 레코드(data base record)를
매핑(mapping)하는 데 사용되는 정의 정보를 말한다.

#6.11

Video.find( {}, callback?: )
{} => search terms, 이게 비어있으면 모든 비디오를 찾게된다.

#6.12
database가 javascript 밖에서 수행되다보니(js와 비동기이다)
find({}, ...)가 다른(console.log같은..)것 보다 늦게 수행된다.

database 검색이 안끝났을때 render하는것을 방지하는법
1.
Video.find({}, (error, videos) => {
    
    return res.render("home", { pageTitle: "Home", videos });
  });
Video.find()의 콜백함수((error, videos) =>) 안에 render를 넣는다.

단점 : function안에 function을 넣어서 깔끔하지않아

#6.13

database 검색이 안끝났을때 render하는것을 방지하는법

2. promise => callback의 최신버전
async(비동기) -- await(수행될 때까지 기다려준다)
=> 데이터베이스가 데이터 찾을때까지 기다려준다(다음 것이 먼저 수행되는 것을 막음)
에러는 try-catch문으로 잡는다.

async function
async function 선언은 AsyncFunction객체를 반환하는 하나의 비동기 함수를 정의합니다.
비동기 함수는 이벤트 루프를 통해 비동기적으로 작동하는 함수로, 암시적으로 Promise를 사용하여 결과를 반환합니다.
그러나 비동기 함수를 사용하는 코드의 구문과 구조는, 표준 동기 함수를 사용하는것과 많이 비슷합니다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function

export const home = async (req, res) => {
  const videos = await Video.find({});
  return res.render("home", { pageTitle: "Home", videos });
};
async function선언으로 비동기함수를 선언하고
await를 써서 db에서 데이터를 찾을때까지 기다린다.

장점: 직관적으로 코드를 보기 편하다.

#6.14
1. return의 역할 : 본질적인 return의 역할보다는 function을 마무리짓는 역할로 사용되고 있음.
- 이러한 경우 return이 없어도 정상적으로 동작하지만 실수를 방지하기 위해 return을 사용
2. render한 것은 다시 render할 수 없음
- redirect(), sendStatus(), end() 등등 포함 (express에서 오류 발생)

#6.15
hashtags: hashtags.split(",").map((word) => `#${word}`)
split(",") => 데이터들을 ,로 잘라서 배열로 돌려준다.
map((word) => `#${word}`) =>배열안의 데이터들에게 #를붙인다.

console.log(video)를 하면 우리가 만들지않은 id가 있는데
create video를 할때 mongoose가 id를 자동으로 만들어준다.

#6.16

db에 데이터를 저장하는 두가지방법
1.모델명.create()사용
2.save()사용


MongoDB의 collection이름이 Video가 아닌 videos인 이유
Mongoose는 자동으로 모델을 찾고, 해당 모델의 이름을 따서 소문자+뒤에 s(복수형)을 붙여 컬렉션을 생성합니다.
Tank 모델은 -> 컬렉션에 저장될 때, tanks로 저장됩니다.

Document.prototype.save()
https://mongoosejs.com/docs/api.html#document_Document-save

Model.create()
하나 이상의 문서를 데이터베이스에 저장하기 위한 손쉬운 방법입니다.
MyModel.create(docs)는 문서의 모든 문서에 대해 새로운 MyModel(doc).save()를 수행합니다.
create()을 하게 되면 save()를 생략할 수 있습니다.
create()이 다음 미들웨어인 save()를 트리거하기 때문입니다.
https://mongoosejs.com/docs/api.html#model_Model.create

Collection: Document들을 담고 있는 묶음

#6.17
Exception & validation
1. try/catch를 통한 에러처리, 에러메세지 전달
2. Schema parameter : default
3. Schema CreatedAt에 Date.now()가 아닌 Date.now를 적는 이유 : 생성될때만 실행되도록
 =>videoSchema 에서 default: Date.now() 라고 하면 그 schema가 있는 파일을 저장하는 시간이 default 로 저장댐

#6.18
More Schema (몽구스 스키마)
몽구스 스키마 타입 확인
Mongoose 스키마는 Mongoose 모델을 구성하기 위한 객체로 생각할 수 있습니다.
https://mongoosejs.com/docs/schematypes.html

몽구스 스키마 타입 정의
몽구스의 모든 것은 스키마로 시작합니다. 각 스키마는 MongoDB 컬렉션에 매핑되고 해당 컬렉션 내 문서의 모양을 정의합니다.
https://mongoosejs.com/docs/guide.html

#6.19
정규식 regular expression
1. mongoose가 부여한 id를 사용하기 위해 id에 숫자만 사용가능하게 설정한 Router부분 변경
- http://regexpal.com 을 통한 정규식 생성하기
2. id를 통해 db 내 색인, 해당 데이터 사용하기

#6.20
Edit Video
1. .exec()에 대한 간략한 설명
2. 사용자가 존재하지 않는 ID에 접근할 경우 => if {404.pug}
3. 일반적으로 에러를 if에 처리, return으로 함수 종료
4. join()으로 배열을 문자열로 통합

#6.21
1. post 복습
2. postEdit 구현, 일일히 수정 => 안 즐겁다
3. startWith()로 # 유무 확인
4. 조건부 연산자 ?를 통한 간결한 조건문

String.prototype.startsWith()
startsWith() 메소드는 어떤 문자열이 특정 문자로 시작하는지 확인하여
결과를 true 혹은 false로 반환합니다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

String.prototype.endsWith()
The endsWith() 메서드를 사용하여 어떤 문자열에서 특정 문자열로 끝나는지를 확인할 수 있으며,
그 결과를 true 혹은 false로 반환한다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

#6.22
Edit part three
1. Model.findByIdAndUpdate()로 불러오기와 수정 한방에 => 즐겁다
2. Model.exist() =>true false 반환
3. 생성이나 업데이트 전 작동해야할 function의 필요성 => Mongoose의 Middleware 활용

#6.23
1. DeprecationWarning에 대해.. useFindAndModify: false로 설정하면 해결됨
2. middleware는 무조건 model이 생성되기 전에 만들어야 한다
3. mongoose의 middleware에서 this키워드는 저장하고자 하는 문서를 가리킴
4. middleware에서 해시태그 관리 구현

cmd 커맨드
1. 몽고 사용하기
> mongo

2. 내가 가진 db 보기
> show dbs

3. 현재 사용 중인 db 확인
> db

4. 사용할 db 선택하기
> use dbName
(현재 수업에서는 `use wetube`)

5. db 컬렉션 보기
> show collections

6. db 컬렉션 안에 documents 보기
> db.collectionName.find()
(현재 수업에서는 `db.videos.find()`)

7. db 컬렉션 안에 documents 내용 모두 제거하기
> db.collectionName.remove({})
(현재 수업에서는 `db.videos.remove({})`)

#6.24
Static function(스태틱 함수)
1. findByIdAndUpdate()에서는 save 훅업이 발생하지 않음 => 다른 방법을 알아보자
2. Video.js에 function을 만들어서 epxort해서 관리하기 => 이것도 괜찮음 근데 다른것도 알아보자
3. static을 사용하면 import 없이도 Model.function()형태로 사용이 가능함 => super cool

Statics
모델에 static 함수를 추가할 수도 있습니다.
스키마에서 컴파일된 모델에 정적 "class" 메서드를 추가합니다.

Static 사용하는 두 가지 방법
```
// Assign a function to the "statics" object of our animalSchema
animalSchema.statics.findByName = function(name) {
return this.find({ name: new RegExp(name, 'i') });
};
// Or, equivalently, you can call `animalSchema.static()`.
animalSchema.static('findByBreed', function(breed) { return this.find({ breed }); });
```
https://mongoosejs.com/docs/guide.html#statics

#6.25
delete

1. Delete Video 구현
2. Delete는 Remove를 대체하며 충분한 이유가 있지 않은 이상 Delete를 사용

Model.findOneAndDelete()
Model.findOneAndRemove()

이 둘은 정말 약간의 차이가 있는데 대부분의 상황에서 타당한 이유가 없는 한
delete를 사용하라고 되어 있음.
https://www.zerocho.com/category/MongoDB/post/579ecb1fc097d015000404dd

여기 글을 읽어보니 몽고 db는 롤백이 안되서 remove를 하면 다시 되돌릴 수 없기에
remove보다 delete를 사용하라고 권장하는듯

#6.26
Search
1. Model.sort()로 정렬 방식 변경
2. Search 구현
3. get 메소드에서 form 값을 가져오기 위해서는 req.query 이용

Query.prototype.sort()
정렬 순서를 설정합니다. 개체가 전달되면 허용되는 값은 asc, desc, 오름차순, 내림차순, 1 및 -1입니다.
https://mongoosejs.com/docs/api.html#query_Query-sort

req.query
라우트 안에 query string parameter를 포함하고 있는 객체로, URL에서 데이터를 가져올 때 주로 사용한다.
예) ?keyword="food" => {keyword: "food"}
query parse가 비활성화로 설정되면 빈 객체 {}이고, 그렇지 않으면 구성된 query parse의 결과입니다.
https://expressjs.com/ko/api.html#req.query

#6.27
Search
1. Model.find()를 통한 Search
2. 오퍼레이터를 통한 Model.find()의 고도화 (mongoDB)
  =>정규식을 통해서 search기능을 정교하게.

Model.find()
documents를 찾습니다. (findOne과 다르게 전체 document를 찾습니다.)
Mongoose는 명령이 전송되기 전에 모델의 스키마와 일치하도록 필터를 캐스팅합니다.
https://mongoosejs.com/docs/api.html#model_Model.find

정규표현식
https://www.regexpal.com

몽고DB regex ($regex)
몽고DB에서 정규표현식을 사용하기 위해 사용하는 키워드
쿼리의 패턴 일치 문자열에 대한 정규식 기능을 제공합니다.
https://docs.mongodb.com/manual/reference/operator/query/regex

RegExp mdn
RegExp 생성자는 패턴을 사용해 텍스트를 판별할 때 사용합니다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp

RegExp 사용 방법
RegExp 객체는 리터럴 표기법과 생성자로써 생성할 수 있습니다.
리터럴 표기법의 매개변수는 두 빗금으로 감싸야 하며 따옴표를 사용하지 않습니다.
생성자 함수의 매개변수는 빗금으로 감싸지 않으나 따옴표를 사용합니다.
```
/ab+c/i 를 아래 RegExp 생성자를 이용해서 만들 수 있습니다.
new RegExp(/ab+c/, 'i') // 리터럴 표기법
new RegExp('ab+c', 'i') // 생성자 함수

#7.0
Create User model.

#7.2
hash password 해시화
해싱 ->입력값을넣으면 출력값이 나온다
 => 출력값으로 입력값을 얻지못한다.
 => 같은입력값으로 항상 같은 출력값이나온다
npm i bcrypt 으로 설치한다.
모델의 pre(save)기능을 이용해 db에 저장하기전에 해싱한다.
userSchema.pre("save", async function () {
  this.password = await bcrypt.hash(this.password, 5);
});
this는 유저가 입력한 데이터를 말한다.
saltRounds => 몇번 해싱할것인지 정하는

해시를 이용해 해킹공격하는 rainbow table이있는데, bcrypt에서 막아줄것이다.

#7.3
Form Validation

$or
$or 연산자는 둘 이상의 조건에 대해 논리적 OR 연산을 수행하고 조건 중 하나 이상을 충족하는 문서를 선택합니다.

// 예시
```
db.inventory.find( { $or: [ { quantity: { $lt: 20 } }, { price: 10 } ] } )

```
https://docs.mongodb.com/manual/reference/operator/query/or/#mongodb-query-op.-or

#7.4
Status Codes
Status Codes 400을 렌더링할때 같이 보내주면
브라우저가 방문 목록을 저장할때 하지않는다.

상태코드
- 200(OK): 서버가 요청을 제대로 처리했다는 뜻이다. 이는 주로 서버가 요청한 페이지를 제공했다는 의미로 쓰인다.
- 400(Bad Request): 서버가 요청의 구문을 인식하지 못할 때 발생한다. 클라이언트 측에서 문제가 있을 때 주로 발생한다.
- 404(Not Found): 서버가 요청한 페이지를 찾을 수 없을 때 발생한다. 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 제공한다.
https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C

res.status(code)
response에 대한 HTTP 상태를 설정합니다. (status를 설정한다.)
https://expressjs.com/ko/api.html#res.status
https://nodejs.org/api/http.html#http_response_statuscode

#7.6
compare hash password 
bcrypt를 이용해서 비밀번호 비교

password: 유저가 입력한 비밀번호
user.passwordHash: DB에 해시화되서 저장된 비밀번호
```
const match = await bcrypt.compare(password, user.passwordHash);
```
https://www.npmjs.com/package/bcrypt

#7.7
session

npm i express-session

1. 브라우져 서버에 접근
2. 서버가 브라우져에게 쿠키(세션id)를 준다.
3. 브라우져가 서버에 다시 접근할 때 2.에서 받은 쿠키(세션id)를 함께 건냄.
4. 서버는 쿠키(세션id)를 통해 브라우져를 구분 할 수 있다.

세션은 오브젝트라 우리가 정보를 붙일수있다.
ex) req.session.user = user;
...
즉 유저를 로그인시키는것은 우리가 req.session 오브젝트 안에
정보를 넣는 것이다.

express-session
Express용 세션 미들웨어
세션 데이터는 쿠키 자체에 저장되지 않고 세션 ID에만 저장됩니다. 세션 데이터는 서버 측에 저장됩니다.
npm i express-session
https://www.npmjs.com/package/express-session

Session 사용 예시
https://github.com/expressjs/session#example

req.session.id 또는 req.sessionID
브라우저가 request할 때 같이 보내는 session id

resave (변경 사항이 없어도 저장)
request하는 동안 세션이 수정되지 않은 경우에도 세션이 세션 저장소에 다시 저장되도록 합니다.
https://github.com/expressjs/session#resave

saveUninitialized (세션 초기화 전에도 저장)
"초기화되지 않은" 세션을 저장소에 강제로 저장합니다.
https://github.com/expressjs/session#saveuninitialized

#7.8
세션 part2

세션은 서버측에서 제공해주는 데이터, 쿠키는 클라이언트측에서 저장하고 사용하는 데이터
  req.sessiontStore() 사용했을때 한번은 undefined가 나온 이유가
  세션은 서버에서 만들어줘야 하는데 클라이언트가 첫 요청때 세션을 가지고있을리 없으니
  undefined이 나온거고 그 이후 요청부턴 첫번째 요청때 세션을 만들어서 넘겨줬으니
  클라이언트가 해당 값을 쿠키에 저장하고 매 요청때마다 서버에게 전달
세션은 서버가 만들어서 제공해주다보니 서버가 재부팅되면 초기화 된다.
  => (그래서 DB에 저장해서 관리를 한다는 소리. 실 운영에선 서버가 꺼지는 일은 없으니깐.)
세션의 값은 서버가 만들어주는 고유값이다보니 해당 값을 기준으로 클라이언트에서 요청한 건에 대해 유저를 특정지을 수 있다
  ==>서버가 세션을 생성한 기점은 middleware로 express-session을 추가했을때부터 생성됨.

====>>
즉, 브라우져에서 서버에 로그인 요청을 해서 로그인이 되면 서버는 세션id를 response해주고
브라우져는 쿠키스토리지에 그 세션id를 보관하고 있다가 이후 다시 서버에 방문할 시에는 그 세션
id만 보여주면 자동으로 로그인되게 해줘서 계속 로그인할 수고를 덜어준다는 것이겠군요.

#7.9~10
res.locals 는 전역번수 오브젝트이다.
pug에서는 session을 바로 읽지못하지만, locals는 읽을수있다.

res.locals

request 범위가 지정된 response 로컬 변수를 포함하는 객체이므로 request, response 주기동안 렌더링된 view에서만 사용할 수 있습니다.
(Pug나 EJS같은 템플릿 엔진에서 사용 가능하다는 의미)
이 속성은 request path, 인증된 사용자, 사용자 설정 등과 같은 request level의 정보를 노출하는 데 유용합니다.
```
// 사용 예시
app.use(function (req, res, next) {
res.locals.user = req.user
res.locals.authenticated = !req.user.anonymous
next()
})
```
https://expressjs.com/ko/api.html#res.locals

#7.12
MongoStore

세션
세션id는 쿠키에 저장돼지만 세션데이터는 서버사이드에 저장됀다.
디폴트로 지정된 서버사이드 스토리지는MemoryStore이다.
 => 서버 메모리에 저장돼기 때문에 서버를 재시작 할때마다 메모리가 지워진다.
 =>그래서 session store(데이터베이스)에 세션을 저장해야한다.

MongoDB의 경우 connect-mongo를 사용한다. => npm i connect-mongo
=>세션을 mongodb에 저장한다.

#7.13
Uninitialized Sessions
방문한 모든 사람, 로그인하지않은사람, 봇의 session을 저장하는게 좋을까?
 =>로그인한사람의 세션만을 저장하는것이 좋다.

**
DB 미들웨어에서
resave: request에서 새로 생성된 session과 기존에 있던 session이 똑같을 때에도 다시 저장할 것인가?
-> 대부분의 경우 false, 공식문서에서도 false를 권장하며 true는 deprecated 상태

saveUninitialized : true
 => 따로 값을 설정하지 않은 전달 받은 날것의 세션을 즉시 Store에 저장 후 세션 주인에게 쿠키를 (답장하듯) 넘겨 준다.

saveUninitialized : false
  => req.session 속 값을 수정하는 그 순간에(session.user=user) 세션을 Store에 저장 후 그제야 쿠키를 전달한다.
  => 세션을 수정하는 행위 자체가 initialize(초기화)하는것이다.
  => 즉 로그인할때 세션에 데이터를 저장하는행위에서만 DB에 세션저장이 됀다.

#7.14
Expiration and Secrets

1. .env 파일 만들기
2. env 파일을 .gitignore에 추가하기. (git에 업로드 하지 않기 위해)
3. 비밀로 해야 하는 string을 process.env.[환경변수이름]으로 바꾸기


Set-Cookie
Set-Cookie HTTP 응답 헤더는 서버에서 사용자 브라우저에 쿠키를 전송하기 위해 사용됩니다.
https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie

쿠키에 설정가능한 옵션
Domain
쿠키가 적용되어야 하는 호스트를 지정.

Expires
HTTP 타임스템프로 기록된 쿠키의 최대 생존 시간(수명).

Max-Age
쿠키가 만료될 때 까지의 시간 (밀리세컨드)

secret
이것은 세션 ID 쿠키에 서명하는 데 사용되는 비밀입니다.
https://www.npmjs.com/package/express-session

COOKIE_SECRET에 넣을 랜덤 문자열 생성 사이트
https://randomkeygen.com/

#7.15
Environment Variables 환경변수

dotenv
Dotenv는 .env 파일에서 process.env로 환경 변수를 로드하는 제로 종속성 모듈입니다.
npm i dotenv

프로젝트에서 될수있는한 가장먼저 dotenv를 import해줘야한다.
 => 이번프로젝트는 init.js가 가장빠르다.
 =>import방법은 두가지있다.
 =>방법1. require(dotenv가필요한 모든파일에)
    방법2. import "dotenv/config"
https://www.npmjs.com/package/dotenv


#7.16
Github Login

1.사용자를 github로 보낸다.
2.사용자가 github로그인하고, github는 유저를 웹사이트로 redirect시킨다(토큰,유저 정보랑같이)
3.토큰을 이용하여 유저정보를 얻는다.


https://github.com/login/oauth/authorize?client_id=입력값&allow_signup=false

Authorizing OAuth Apps
다른 사용자가 OAuth 앱을 승인하도록 할 수 있습니다.
GitHub의 OAuth 구현은 웹 브라우저에 대한 액세스 권한이 없는 앱에 대한 표준 인증 코드 부여 유형 및 OAuth 2.0 장치 인증 부여를 지원합니다.

Web application flow
웹 애플리케이션 흐름: 브라우저에서 실행되는 표준 OAuth 앱에 대해 사용자에게 권한을 부여하는 데 사용됩니다.
앱 사용자에게 권한을 부여하는 웹 애플리케이션 흐름은 다음과 같습니다.
1. 로그인하려는 사이트에서 유저의 GitHub identity를 request하기 위해 유저를 GitHub 페이지로 리다이렉트시킵니다.
2. 유저는 리다이렉트된 GitHub에서 승인을 하고, GitHub에 의해 다시 로그인하려는 사이트로 리다이렉트됩니다.
3. 로그인 하려는 사이트는 유저의 액세스 토큰을 통해 API에 접근합니다.
https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps

깃허브 OAuth Apps Setting
GitHub API를 사용하기 위해 등록한 애플리케이션입니다.
https://github.com/settings/developers

Scopes for OAuth Apps (OAuth 앱의 범위)
https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps

Creating an OAuth App (OAuth앱 만들기)
https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app

#7.17

긴 URL은 그대로 쓰는게아니라, 변수를만들어 관리하자.


&scope=read:user
&scope=read:user user:email

Scopes for OAuth Apps
OAuth 앱은 초기 리디렉션에서 범위를 요청할 수 있습니다. %20을 사용하여 공백으로 구분하여 여러 범위를 지정할 수 있습니다.
// 사용 예시
```
https://github.com/login/oauth/authorize?client_id=...&scope=user%20repo_deployment
```
https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps

URLSearchParams
URLSearchParams 인터페이스는 URL의 쿼리 문자열에 대해 작업할 수 있는 유틸리티 메서드를 정의합니다.
https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams

URLSearchParams.toString()
toString() 은 URLSearchParams 인터페이스의 메소드로서, URL에서 사용할 수 있는 쿼리 문자열을 리턴합니다.
https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams/toString

https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps

#7.18

깃허브에서 보내준 코드로 access_token이란것을 받아야하는데,
그를위해 POST Request를 보내야한다.
POST reqeust를 보내는데는, fetch()를 쓰면 좋은데(), 서버에는 없고 브라우저에만 있는 기능이다.
 =>node-fetch라는 패키지로 쓸수있다.

Users are redirected back to your site by GitHub

사용자가 요청을 수락하면 GitHub는 코드 매개변수의 임시 code와 상태 매개변수의 이전 단계에서 제공한 state를 사용하여 사이트로 다시 리디렉션합니다.

POST Request를 할 때, 반드시 필요한 파라미터들
client_id, client_secret, code
```
POST https://github.com/login/oauth/access_token
```
https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps#2-users-are-redirected-back-to-your-site-by-github

#7.19
node-fetch
JS와 NodeJS는 다른 플랫폼이기때문에 fetch를 쓰려면 node-fetch를 써야한다.
npm i node-fetch

github에서 받은 코드로 access_token을 얻을수있는데, GitHub API를 이용해 user 정보를 얻을수있다.

[2022.01.24] HTTP headers (fetch의 header의 역할)

HTTP headers는 는 클라이언트와 서버가 request(or response)로 부가적인 정보를 전송할 수 있도록 해줍니다

Accept
돌려줄 데이터 타입에 대해 서버에게 알려주는 역할을 합니다
MIME 타입입니다
(📌MIME type이란 웹에서 사용되는 확장자라고 생각하시면 되며
type/subtype으로 구성되어 있습니다)

Authorization
보호된 리소스에 대한 접근을 허용하여 서버로 User agent를 인증하는 자격증명을 보내는 역할을 합니다

[출처]
HTTP headers: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers
MIME tyeps: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types

****
Error [ERR_REQUIRE_ESM]: require() of ES Module 오류 발생 시 두 가지 방법 중 하나로 해결할 수 있습니다.

1. node-fetch 3버전이 아닌 2버전으로 다운그레이드된 버전을 설치해서 해결할 수 있습니다.
npm i node-fetch@2.6.1 (강의과 같은 버전)
https://www.npmjs.com/package/node-fetch

2. cross-fetch 사용 (CommonJS, ES6 모듈, Typescript등에서도 사용가능)
node-fetch대신 사용할 수 있는 cross-fetch 패키지를 통해 해결할 수 있습니다. node-fetch와 사용법은 동일합니다.
Node, 브라우저 및 React Native용 범용 WHATWG Fetch API.
npm i cross-fetch
```
import fetch from 'cross-fetch';

fetch(...)
```
https://www.npmjs.com/package/cross-fetch

node-fetch 버전3 문제
v3의 node-fetch는 ESM 전용 모듈입니다. require()로 가져올 수 없습니다. ESM으로 전환할 수 없는 경우 CommonJS와 호환되는 v2를 사용하십시오. 중요한 버그 수정은 v2에 대해 계속 게시됩니다.

Use the access token to access the API
액세스 토큰을 사용하면 유저를 대신해 API에 요청할 수 있습니다.
```
Authorization: token OAUTH-TOKEN
GET https://api.github.com/user
```
https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps#3-use-the-access-token-to-access-the-api
****

#7.20

Github REST API (User)
사용자 API를 사용하면 인증된 사용자에 대한 공개 및 비공개 정보를 얻을 수 있습니다.
https://docs.github.com/en/rest/reference/users

Get the authenticated user
인증된 사용자가 기본 인증 또는 사용자 범위의 OAuth를 통해 인증되면 응답에 공개 및 비공개 프로필 정보가 나열됩니다. 인증된 사용자가 사용자 범위 없이 OAuth를 통해 인증된 경우 응답에는 공개 프로필 정보만 나열됩니다.

Add an email address for the authenticated user
https://docs.github.com/en/rest/reference/users#add-an-email-address-for-the-authenticated-user

List public email addresses for the authenticated user
인증된 사용자의 공개 이메일 주소 나열
https://docs.github.com/en/rest/reference/users#list-public-email-addresses-for-the-authenticated-user

#7.21
로그인 규칙을 어떻게 만들것인가?
=>깃허브 email이 verified, primary이고, DB에 똑같은 email이 있으면 로그인시킨다.
=> DB에 일치하는 데이터가없으면, 깃허브 유저정보를 이용해 유저를 생성시키고, 로그인시킨다.

#7.22

로그아웃

Session.destroy(callback)

세션을 파괴하고 req.session 속성을 설정 해제합니다. 완료되면 콜백이 호출됩니다.
```
req.session.destroy(function(err) {
// cannot access session here
})
```
https://www.npmjs.com/package/express-session

#7.23

카카오 로그인 구현하기 (REST API)
카카오 로그인 구현하실 분들은 아래 링크들을 참조하시면 됩니다.
구현 방식은 깃허브 로그인과 거의 동일합니다.
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api

0. 애플리케이션 등록
https://developers.kakao.com/docs/latest/ko/getting-started/app

1. 인가 코드 받기
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#request-code

2. 토큰 받기
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#request-token

3. 사용자 정보 가져오기
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#req-user-info

#8.0
Edit Profile

로그인하지 않은 유저는 edit페이지에 접근할수 없어야한다.
 =>로그인하지않았다면, middlewares.js에서 lcoals의 user오브젝트는 정의돼지 않으므로,
  에러가 난다.
  =>로그인하지 않았다면 빈 오브젝트를 돌려주어 일단 에러는 막는다.res.locals.loggedInUser = req.session.user || {};

#8.1

Protector and Public Middlewares

각 페이지마다 접근 가능한 사람을 제한해야 한다.
=>middleware를 추가하여 각 라우터에 용도에 맞게 붙혀준다.
=>all()함수는 get.post둘다있는 라우터에 둘다 적용할수있게 해준다.

#8.2

edit Profile
POST로 입력값을 받아와서 업데이트를 하면
DB값은 업데이트돼지만, 세션은 업데이트돼지 않는다.
세션도 업데이트를 해줘야 바뀐 값이 반영됀 user 오브젝트가
세션에 들어가게 됀다.

Model.findByIdAndUpdate()

문서의 _id 필드로 mongodb findAndModify 업데이트 명령을 실행합니다. findByIdAndUpdate(id, ...)는 findOneAndUpdate({ _id: id }, ...)와 동일합니다.

```
// 사용 예시
Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options, callback)

// is sent as (+타입스크립트)
Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options, callback)
```
https://mongoosejs.com/docs/api.html#model_Model.findByIdAndUpdate

#8.3
edit Profile
DB의 업데이트는 프론트엔드에 반영돼지않는다.
프론트엔드는 session에서 정보를 얻기 때문이다.
session은 로그인할때 한번만 작성돼고있다.

업데이트후 따라서 세션도 업데이트 해줘야한다.

#8.4
change password 

github로그인의경우, password가 없기때문에, 비밀번호 변경페이지를 못봐야한다.

#8.5

change password #2

password를 해쉬화 하기위해해서는 모델의pre(save)를 발동시켜야하는데,
그를위해 두가지 방법이있다.

1.pre save middleware를 거치고 User.create()를 사용해야한다.
2.user.save()를해도 pre save middleware를 작동시킨다.

**
DB를 바꿔도 세션안에있는데이터는 그대로니, user.save()후에 세션도 업데이트해주자.



bcrypt
// 비밀번호 비교
const match = await bcrypt.compare(password, user.passwordHash);
https://www.npmjs.com/package/bcrypt

Model.findByIdAndUpdate()
findByIdAndUpdate로는 pre('save')를 실행시키지 않기 때문에 비밀번호가 해시화되지 않고 DB에 저장되게 된다. 그래서 save()메서드를 통해 pre('save')를 실행시켜 비밀번호를 해시화한 후 DB에 저장될 수 있도록 해준다.
https://mongoosejs.com/docs/api.html#model_Model.findByIdAndUpdate

Model.prototype.save()
findByIdAndUpdate를 이용해서 Document업데이트 후 save하기
앞서 했던 것처럼 findByIdAndUpdate를 통해 Document를 업데이트 시키고 업데이트된 최신 Document를 받아서 save를 할 수도 있습니다.
(자바스크립트로 진행하신다면 $set은 사용하지 않으셔도 됩니다.)
```
const updatedUser = await User.findByIdAndUpdate(loggedInUser?._id, { $set: { password: newPassword } }, { new: true });
await updatedUser?.save();
```
https://mongoosejs.com/docs/api.html#model_Model-save

await user.save();
return res.redirect("/users/logout");

위와 같은 형태로 구현하면 해커들이 로직파악 후에 302 redirect를 프록시를 통해서 막은 후에 이전 세션 데이터도 활용할 수 있게 됩니다. 좀더 안전하게 하려면 아래와 같이 확실하게 destroy해주는게 좋아보여요.

req.session.destroy();
return res.redirect('/login');

추가로 이전비밀번호와 변경비밀번호가 같으면 튕겨주는게 좋을 듯 합니다.

if (oldPassword === newPassword) {
return res.status(400).render('users/change-password', {
pageTitle,
errorMessage: 'The old password equals new password',
});
}

#8.6
File Upload
파일업로드를 하기위해 준비해야할2가지
1.input + label 조합
   label(for="avatar") Avatar
   input(type="file", id="avatar", name="avatar", accept="image/*")
2. Multer middleware 사용 => npm i multer
  2-1) form에 enctype="multipart/form-data속성 추가.
    => form(method="POST", enctype="multipart/form-data")
  2-2) multer middleware를 작성
    => import multer from "multer";
    => export const uploadFiles = multer({ dest: "uploads/" });
  2-3) router에 적용.
    =>.post(uploadFiles.single("avatar"), postEdit);
    순서가 중요하다. postEdit전에 uploadFiles를 실행해야
    컨트롤러에서 req.file을 사용할수있다.

https://kasterra.github.io/what-is-multipart-form-data/
https://www.npmjs.com/package/multer

Multer
Multer는 주로 파일 업로드에 사용되는 multipart/form-data를 처리하기 위한 node.js 미들웨어입니다.
주의! Multer는 multipart(multipart/form-data)가 아닌 form을 처리하지 않습니다.
npm i multer
enctype="multipart/form-data"
https://www.npmjs.com/package/multer

multer(opts)
dest 또는 storage: 파일을 저장할 위치
fileFilter: 허용되는 파일을 제어하는 ​​함수
limits: 업로드된 데이터의 한계
preservePath: 기본 이름 대신 파일의 전체 경로 유지

사용 예시
```
const multer = require('multer')
const upload = multer({ dest: './public/data/uploads/' })
app.post('/stats', upload.single('uploaded_file'), function (req, res) {
// req.file is the name of your file in the form above, here 'uploaded_file'
// req.body will hold the text fields, if there were any
console.log(req.file, req.body)
});
```

.single(fieldname)
이름이 fieldname인 단일 파일을 수락합니다.
단일 파일은 req.file에 저장됩니다.

#8.7
****
DB에는 파일을 직접 저장하지않는다.
  =>파일 위치만 저장하고, 업로드 폴더에 파일을저장한다.

edit Profile => File Upload

사용자가 프로필수정시 프사를 안바꿀수도있다.
그런경우 req.file은 undefined이다.
이부분을 유의해, 세션에있는 avatarUrl을 이용한다.
  const {
      session: {
        user: { _id, avatarUrl },
      },
  avatarUrl: file ? file.path : avatarUrl,

#8.8

Static Files

폴더를 브라우저에 노출시켜야 브라우저가 파일을 읽을수있다.
app.use("/uploads", express.static("uploads"));


express.static(root, [options])

Express에 내장된 미들웨어 기능입니다. 정적 파일을 제공하며 serve-static을 기반으로 합니다. root 인수는 static asset을 제공할 root 디렉토리를 지정합니다. 이 함수는 req.url을 제공된 root 디렉토리와 결합하여 제공할 파일을 결정합니다.

https://expressjs.com/ko/api.html#express.static

#8.9

Video Upload

샘플 비디오 파일
https://sample-videos.com/
https://sample-videos.com/video123/mp4/720/big_buck_bunny_720p_1mb.mp4

multer limit
fileSize: multipart forms의 경우 최대 파일 크기 (바이트)
https://www.npmjs.com/package/multer

Byte to MB
1000000 Bytes(백만 Bytes) = 1 MB (in decimal)
1000000 Bytes = 0.95367431640625 MB (in binary)
https://www.gbmb.org/bytes-to-mb

#8.11
Video Owner
비디오모델에 owner스키마를 줘서 유저id를저장시킨다.
ObjectId는 몽구스에서만 제공하는것으로
type: mongoose.Schema.Types.ObjectId로 쓸수있다.
이것은 String타입이 아니다.

Cannot read properties of undefined (reading '_id') 오류 해결 방법

혹시 위와 같은 오류가 발생하시면 아래와 같이 if loggedInUser를 추가해주시면 됩니다.
```
if loggedInUser
if String(video.owner) === String(loggedInUser._id)
a(href=`${video.id}/edit`) Edit Video →
br
a(href=`${video.id}/delete`) Delete Video →
```

Mongoose Schema Types
https://mongoosejs.com/docs/schematypes.html

ObjectId
ObjectId는 일반적으로 고유 식별자에 사용되는 특수 유형입니다. ObjectId는 클래스이고 ObjectId는 객체입니다. 그러나 종종 문자열로 표시됩니다. toString()을 사용하여 ObjectId를 문자열로 변환하면 24자의 16진수 문자열을 얻습니다.
_someId: Schema.Types.ObjectId,
https://mongoosejs.com/docs/schematypes.html#objectids

Mongoose Typescript ObjectIds및 다른 타입 설정
https://mongoosejs.com/docs/typescript.html#objectids-and-other-mongoose-types

#8.12
8.11에서 video의 owner스키마에 user의 id를 저장시켰으니,
이를 이용해서 video모델을 불러올때, user의 정보를 가져올수있다.
const video = await Video.findById(id).populate("owner");
owner스키마의 ref속성에서 User를 참조하는것을 알려줬으므로,
populate("owner");에 owner를 주면 몽구스가 user정보를 찾아
video모델에 넣어준다.(이메일,이름,아이디..등)



populate
Mongoose에는 populate()를 통해 다른 컬렉션의 문서를 참조할 수 있습니다. Population은 문서의 지정된 경로를 다른 컬렉션의 문서로 자동 교체하는 프로세스입니다. 단일 문서, 여러 문서, 일반 개체, 여러 일반 개체 또는 쿼리에서 반환된 모든 개체를 채울 수 있습니다.
const story = await Story.findOne({ title: 'Casino Royale' }).populate('author');
https://mongoosejs.com/docs/populate.html

Population
https://mongoosejs.com/docs/populate.html#population

#8.13

User모델에도 videos 스키마를 추가해서 비디오목록을 표시할수있게.
videos: [{ type: mongoose.Schema.Types.ObjectId, ref: "Video" }],
  => 이제 유저를 찾을때 가진 비디오목록의 정보까지 찾을수있다.
  const user = await User.findById(id).populate("videos");

#8.14
Bugfix
user의 videos를 추가할때 컨트롤러에서 save()를 해줘야하는데,
그때마다 비밀번호의 해싱이 일어난다.=> 비밀번호가 바뀐다.
  =>if this.isModefied("password")메서드를 사용하여 비밀번호가 바뀔때만 해싱하도록하자.

video.owner의 id는 object이고, req.session.user._id는 String이므로
!==타입 변화에서 같게 보여도 결과는 에러가 난다.
(String)으로 캐스팅을 해주자.

#9.0
babel-node 는 node.js(백엔드)가 javascript를 알아먹을수있게 도와주는
똑같은게 프런트엔드에도 필요하다.
  =>Webpack이 브라우저에게 javascript와 css를 이해하게 전달한다.
  =>리액트 등의 프레임워크들은 Webpack을 내장하고있기떄문에 기본적으로는
  직접 Webpack을 다룰일은 없다.
Webpack

Webpack은 모듈 번들러입니다. 주요 목적은 브라우저에서 사용할 JavaScript 파일을 번들로 묶는 것이지만 거의 모든 리소스나 asset을 변환, 번들링 또는 패키징할 수도 있습니다.

https://webpack.js.org

#9.1
Webpack Configuration
npm i webpack webpack-cli -D
src/client폴더 생성 =>webpack에 전달할 프론트엔드 파일들을 담는곳

webpack.config.js 생성
  entry : 우리가 처리하고자할 파일들(최신js코드들)의 위치
  output : 결과물 위치, 이름

pacakge.json->scripts에 dev외에 실행어 설정"assets": "webpack --config webpack.config.js"

***
Webpack은 .jpg 같은 거는 압축된 jpg 를 주고, JS 는 못생긴 거로, Sass 는 몬생긴 css 로 준다. 압축, 변형, 최소화등 필요한 작업들을 거치고 정리된 코드를 결과물로 준다.

webpack, webpack-cli devDependencies 로 설치

webpack아 여기는 소스파일들이 있고 여기는 너가 결과물을 보낼 폴더야
webpack.config.js 파일에서 webpack 환경설정. 이 파일에서는 되게 몬생긴 JS 만 쓸 수 있다.

중요한 거 두 가지(필수 설정)

- entry: 우리가 처리하고자 하는 파일들(예쁜 js)
- entry: 이 프로퍼티에 우리가 처리하고자 하는 파일의 경로 입력
- output: 결과물
- filename: 이 프로퍼티에 우리 결과물이 될 파일 이름 입력
- path: 이 프로퍼티에 우리 결과물 파일을 어디에 저장할 지 지정 (이 경로는 절대경로여야 해!)

***
Wepback 설치
npm i webpack webpack-cli -D
Webpack 시작하기: https://webpack.kr/guides/getting-started/
Webpack 설정: https://webpack.kr/concepts/configuration/

Typescript환경에서 Webpack 설정하기
npm install --save-dev typescript ts-loader webpack webpack-cli
https://webpack.kr/guides/typescript/

#9.2

webpack

webpack.config.js
 output:path는 절대경로(전체경로)가 필요하다. 
 __dirname은 파일까지의 전체경로이다.
 const path = require("path");
  path.resolve(path1,2,..) 안에 들어가는 파라메터 몇개든 전체경로로 이어준다.
  rules: 우리가 각각의 파일종류에 따라 어떤 전환을 할지 결정

path.resolve([...paths])
path.resolve() 메서드는 경로 세그먼트 시퀀스를 절대 경로로 해석하는 데 사용됩니다. 경로 세그먼트가 전달되지 않으면 path.resolve()는 현재 작업 디렉토리의 절대 경로를 반환합니다.
(__dirname: 현재 파일 위치의 절대 경로)
```
path.resolve('/foo/bar', './baz');
// Returns: '/foo/bar/baz'
```
https://nodejs.org/api/path.html#pathresolvepaths

babel-loader
npm install babel-loader -D
https://github.com/babel/babel-loader

webpack loader
https://webpack.kr/loaders/

webpack babel-loader
https://webpack.kr/loaders/babel-loader/

main.js에 빈 파일 나오는 오류 해결 방법
mode를 설정해주지 않으면 기본적으로 production으로 설정되어 client/js폴더 내에 작성한 main.js를 변환했을 때, 빈 파일로 나올 수 있습니다.
빈 파일 나오시는 분들은 module.export안에 mode: "development"로 설정해주시면 됩니다.

Typescript webpack.config.js 설정
https://webpack.kr/guides/typescript/

#9.3

Express에게 assets폴더를 유저들이 볼수있게 공개하는 설정을 해야한다.(예전 uploads폴더처럼)
server.js
  app.use("/static", express.static("assets"));
  static은 아무이름이어도 상관없다. url이름일뿐.

#9.4
Webpack.config.js설정시
test: /\.scss$/,
        use: ["style-loader", "css-loader", "sass-loader"],
오른쪽부터 왼쪽으로 읽기때문에 반대순서로 작성해야함.(순서를잘지켜야)

sass, sass-loader, css-loader, style-loader 설치
npm i sass sass-loader css-loader style-loader -D

sass-loader
Sass/SCSS 파일을 로드하고 CSS로 컴파일합니다.
https://webpack.js.org/loaders/sass-loader/

SCSS
Variable
Sass 변수는 간단합니다. $로 시작하는 이름에 값을 할당하면 값 자체 대신 해당 이름을 참조할 수 있습니다.
```
$base-color: #c6538c;
$border-dark: rgba($base-color, 0.88);

.alert {
border: 1px solid $border-dark;
}
```
https://sass-lang.com/documentation/variables

@import
@import CSS at-rule은 다른 스타일 시트에서 스타일 규칙을 가져오는 데 사용됩니다.
https://developer.mozilla.org/en-US/docs/Web/CSS/@import
https://sass-lang.com/documentation/at-rules/import#plain-css-imports

#9.5

style-loader이라는 loader를 사용하면, javascript코드가 css파일을 읽는데,
우리는 css파일 따로, js파일 따로 웹팩으로 번들화 시키고싶다. 한번에 할 경우 js 로딩을 기다려야하기 때문이다.
그래서 MiniCssExcractPlugin.loader를 사용한다.

MiniCssExtractPlugin
이 플러그인은 CSS를 별도의 파일로 추출합니다. CSS가 포함된 JS 파일별로 CSS 파일을 생성합니다. mini-css-extract-plugin을 css-loader와 결합하는 것이 좋습니다.

npm install --save-dev mini-css-extract-plugin
https://webpack.kr/plugins/mini-css-extract-plugin/

MiniCssExtractPlugin Options
```
plugins: [new MiniCssExtractPlugin({ filename: "css/style.css" })]
```
https://webpack.js.org/plugins/mini-css-extract-plugin/#publicpath

CssMinimizerWebpackPlugin
https://webpack.kr/plugins/css-minimizer-webpack-plugin/

#9.6
프론트엔드 파일을 수정할때, 백엔드서버를 재시작하기싫고,
백엔드파일을 수정할떄, 프론트엔드서버를 재시작하기싫다.
그러기위해, pacakge.json설정을 바꾸자.
nodemon.json파일을 만들어 추가하자.

Watch and WatchOptions
Webpack은 파일이 변경될 때마다 이를 감지하여 다시 컴파일 할 수 있습니다.

watch
watch 모드를 켭니다. 이제 초기 빌드 후 webpack은 해석 된 파일의 변경 사항을 계속 감시합니다. (webpack.config.js에 entry에 지정한 파일을 감시한다.)
https://webpack.kr/configuration/watch/

Nodemon
nodemon은 디렉토리의 파일 변경이 감지되면 노드 응용 프로그램을 자동으로 다시 시작하여 node.js 기반 응용 프로그램을 개발하는 데 도움이 되는 도구입니다.
https://github.com/remy/nodemon

Sample nodemon.json
https://github.com/remy/nodemon/blob/master/doc/sample-nodemon.md

Nodemon Config file
https://github.com/remy/nodemon#config-files

#11.1
비디오 플레이어 만들기
play pause
각 함수마다 하나씩 기능을 맡아 구현한다.

#11.4
Duration and Current Time
비디오의 메타데이타
metadata = 비디오를제외한 모든데이터 ->재생시간, 가로세로길이..

HTMLMediaElement
https://developer.mozilla.org/ko/docs/Web/API/HTMLMediaElement

Audio, Video 등에 사용 가능한 이벤트

loadeddata (en-US)
미디어의 첫번째 프레임이 로딩 완료된 시점에 발생합니다.

timeupdate (en-US)
currentTime 속성이 변경되는 시점에 발생합니다.

이벤트 발생순서
loadedmetadata -> loadeddata -> canplay -> canplaythrough
https://developer.mozilla.org/ko/docs/Web/API/HTMLMediaElement#%EC%9D%B4%EB%B2%A4%ED%8A%B8

#11.5
Time Formatting

비디오 재생시간 포멧을위해 Date()를 이용한다.

const formatTime = (seconds) => {
const startIdx = seconds >= 3600 ? 11 : 14;
return new Date(seconds * 1000).toISOString().substring(startIdx, 19);
};

현재 21년 12월 기준으로는 substr 함수는 자바스크립트에서 권장되는 함수가 아니라서 취소선이 그어질겁니다. 대신에 subString 함수를 이용해주세요.
이때, substr 함수랑 조금 차이점이 있는데
subString(시작인덱스, 종료인덱스) substr(시작인덱스, 길이)
이렇게 두번째 파라미터가 다릅니다. 이를 주의해 주세요. 그리고 subString 시작 인덱스는 0부터 입니다.

#11.7
Fullscreen
Fullscreen API
Fullscreen API 는 특정 요소 Element(와 해당 자손들을)를 full-screen mode로 표시하고, 더 이상 필요하지 않으면 full-screen mode를 종료하는 메서드를 추가합니다.

Element.requestFullscreen() (en-US)
유저 에이전트가 지정한 요소(그리고 그 자손들까지)를 full-screen mode로 설정하고, 브라우저의 모든 UI 요소와 다른 모든 애플리케이션을 화면에서 제거하도록 요구합니다. full-screen mode가 활성화되면 Promise resolved를 반환합니다.

Document.exitFullscreen() (en-US)
user agent 가 full-screen mode에서 창 모드로 다시 전환되도록 요청합니다. full-screen mode가 완전히 종료되면 Promise resolved 를 반환합니다.

DocumentOrShadowRoot.fullscreenElement (en-US) (사용 추천)
fullscreenElement 속성은 DOM(혹은 shadow DOM)에서 현재 full-screen mode로 표시되는 요소Element를 알려줍니다. 이것이 null인 경우, document는 full-screen mode가 아닙니다.

Document.fullscreen (en-US) (더 이상 사용되지 않는 속성)
(fullscreenElement처럼 풀스크린을 감지할 수 있지만 사용 비추천)
문서에 현재 full-screen mode로 표시되는 요소가 있는 경우 true, 그렇지 않으면 false의 Boolean 값입니다.

https://developer.mozilla.org/ko/docs/Web/API/Fullscreen_API

#11.8
Controls Events

mousemove, mouseleave는 있지만 mousestop은 없다.
그래서 있는 두개를 이용해야

1. 아무것도 없는 상태에서 비디오 위로 마우스 움직임.
2. 즉시 showing이라는 클래스가 추가되고 3초짜리 showing을 지우는 타이머를 시작시킴.
3. 2초후 마우스를 다시 움직임.
4. if문 구절 때문에 3초짜리 showing을 지우는 타이머가 사라져 버리고, 타이머 값이 null로 바뀜 즉 타이머 사라짐.
5.그대로 클래스 showing만들고 다시 또다른 3초짜리 showing을 지우는 타이머 시작!.

Mouse events
https://developer.mozilla.org/en-US/docs/Web/API/Element#mouse_events

기본 로직
1. 마우스를 움직이게 되면 기존 setTimeout이 clearTimeout에 의해 지워지고, 새로운 setTimeout이 생성되고, 실행되게 된다.
2. 그 상태에서 마우스를 움직이지 않으면 새로운 setTimeout이 3초 후에 실행되게 되서 비디오 컨트롤바를 숨긴다.
3. 움직이게 되면 다시 위의 1번처럼 기존 setTimeout은 clearTimeout에 의해 지워지고, 새로운 setTimeout이 생성된다.

#12.0
Register View Controller

템플릿을 렌더링하지않는 뷰를 api view라고한다.(요즘대세)
  보통은 백엔드가 인증, DB등을처리하고
  프론트엔드는 바닐라JS, 리엑트JS, Svelte등으로 만듬
    우리의 유튭사이트는 Server Side Rendering방식이다.
      =>서버가 템플릿을 렌더링하는일까지 처리하는거

동영상시청이 끝남
-> videoPlayer.js에 비디오 엘레멘트에 이벤트리스너 등록(조회가끝날때, 조회수올려주는 URL호출)
  비디오 엘레멘트만 쓸수있는 이벤트들이있다(timeupdate, ended등..)
->videoPlayer.js에서 비디오id를 찾아, POST request를 보내고싶은데 비디오id를 찾을방법이 없다.
-> HTML의 Data Attributes기능을 이용하여 id정보를 pug에서 저장하여 videoPlayer.js로 가져온다.
  div#videoContainer(data-id=video._id)
    나중에 element.dataset으로 데이터에 접근할수있다.
->이를 이용하여 POST reqeust를보내는 컨트롤러를 완성한다.
const handleEnded = () => {
  const { id } = videoContainer.dataset;
  fetch(`/api/videos/${id}/view`, {
    method: "POST",
  });
};


ended event
audio 또는 video 미디어가 끝까지 재생 완료 된 시점에 발생합니다.
ended 이벤트는 미디어(오디오나 비디오)의 끝 부분에 도달했거나 더 이상 사용할 수 있는 데이터가 없어서 재생 또는 스트리밍이 중지되면 시작됩니다.
https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/ended_event

HTMLMediaElement
https://developer.mozilla.org/ko/docs/Web/API/HTMLMediaElement

Data Attributes
HTML5 특정 요소와 연관되어 있지만 확정된 의미는 갖지 않는 데이터에 대한 확장 가능성을 염두에 두고 디자인되었습니다. data-* 속성은 표준이 아닌 속성이나 추가적인 DOM 속성, Node.setUserData()과 같은 다른 조작을 하지 않고도, 의미론적 표준 HTML 요소에 추가 정보를 저장할 수 있도록 해줍니다.
https://developer.mozilla.org/ko/docs/Learn/HTML/Howto/Use_data_attributes

#12.2

status(), sendStatus()는 다르다.
status()는 렌더링을하거나, 다른거를할때 쓴다(req에의한 연결을 끊지못해 계속 대기한다.)
  statuscode를 정하는것일 뿐이다.
sendStatus()는 연결을 끊는다.
  statuscode를 보내면서 연결을 끊음

#13.0
Recorder setup

프론트엔드에서 async await를 쓰기위해서는 
regenerator-runtime을 설치하여 import해줘야한다.
 => main.js에서 import하고, main.js를 base.pug에서 불러 모든곳에서 사용하게하자.


MediaDevices.getUserMedia()
MediaDevices 인터페이스의 getUserMedia() 메서드는 사용자에게 미디어 입력 장치 사용 권한을 요청하며, 사용자가 수락하면 요청한 미디어 종류의 트랙을 포함한 MediaStream (en-US)을 반환합니다. 스트림은 카메라, 비디오 녹화 장치, 스크린 공유 장치 등 하드웨어와 가장 비디오 소스가 생성하는 비디오 트랙과, 마이크, A/D 변환기 등 물리적과 가상 오디오 장치가 생성하는 오디오 스트림, 그리고 그 외의 다른 종류의 스트림을 포함할 수 있습니다.
보통, MediaDevices 싱글톤 객체는 다음과 같이 navigator.mediaDevices를 사용해 접근합니다.
navigator.mediaDevices.getUserMedia(constraints);
https://developer.mozilla.org/ko/docs/Web/API/MediaDevices/getUserMedia

constraints
요청할 미디어 유형과 각각에 대한 요구사항을 지정하는 MediaStreamConstraints 객체. constraints 매개변수는 두 개의 구성 요소, video와 audio를 가지는 객체로, 요청할 미디어 유형에 대해 설명합니다. 둘 중 적어도 하나는 지정해야 합니다.
{ audio: true, video: true }

regenerator-runtime
Regenerator로 컴파일된 생성기 및 비동기 함수를 위한 독립 실행형 런타임입니다.
npm i regenerator-runtime
import regeneratorRuntime from "regenerator-runtime";
https://www.npmjs.com/package/regenerator-runtime

#13.1
Video Preview
HTMLMediaElement srcObject

HTMLMediaElement 인터페이스의 srcObject 속성은 HTMLMediaElement와 연결된 미디어의 소스 역할을 하는 객체를 설정하거나 반환합니다.
그 객체는 MediaStream, MediaSource, Blob 또는 파일(Blob에서 상속됨)일 수 있습니다.

사용 예시
이 예에서 카메라의 MediaStream은 새로 생성된 요소에 할당됩니다.
```
const mediaStream = await navigator.mediaDevices.getUserMedia({video: true});
const video = document.createElement('video');
video.srcObject = mediaStream;
```

https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/srcObject

#13.2
Recording Video

ondataavailable
 =>MediaRecorder.stop()이 실행될때 발생하는 이벤트이다.


MediaRecorder
MediaStream Recording API의 MediaRecorder 인터페이스는 미디어를 쉽게 녹화할 수 있는 기능을 제공합니다. MediaRecorder() 생성자를 사용하여 생성됩니다.
https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder

MediaRecorder()
기록할 MediaStream이 지정된 새 MediaRecorder 개체를 만듭니다.

stream
기록될 MediaStream입니다. 이 소스 미디어는 navigator.mediaDevices.getUserMedia()를 사용하여 생성된 스트림이나 audio, video 또는 canvas 요소에서 가져올 수 있습니다.

MediaRecorder.start()
미디어 녹화를 시작합니다. 이 메서드는 선택적으로 밀리초 단위의 값을 가진 타임슬라이스 인수를 전달할 수 있습니다.

MediaRecorder.stop()
저장된 데이터의 최종 Blob을 포함하는 dataavailable 이벤트가 발생하는 시점에서 기록을 중지합니다.

MediaRecorder ondataavailable
MediaRecorder.stop()이 실행될 때 발생하는 이벤트이다.
https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/ondataavailable

#13.3

URL.createObjectURL()은 브라우저 메모리 상에서만 쓸수있는 URL을 생성한다.

URL.createObjectURL()

URL.createObjectURL() 정적 메서드는 주어진 객체를 가리키는 URL을 DOMString으로 반환합니다.
해당 URL은 자신을 생성한 창의 document가 사라지면 함께 무효화됩니다.

object
객체 URL을 생성할 File, Blob, MediaSource 객체.
const objectURL = URL.createObjectURL(object)

https://developer.mozilla.org/ko/docs/Web/API/URL/createObjectURL

#13.4

Downloading File 

a
download
링크로 이동하는 대신 사용자에게 URL을 저장할지 물어봅니다. 값을 지정할 수도 있고, 지정하지 않을 수도 있습니다.
https://developer.mozilla.org/ko/docs/Web/HTML/Element/a

MediaRecorder
https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder

Mime type
https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter

#14.0

FFmpeg
오디오 및 비디오를 기록, 변환 및 스트리밍하는 완벽한 크로스 플랫폼 솔루션입니다. FFmpeg는 인간과 기계가 만든 거의 모든 것을 디코딩, 인코딩, 트랜스코딩, mux, demux, 스트리밍, 필터링 및 재생할 수 있는 최고의 멀티미디어 프레임워크입니다.
https://www.ffmpeg.org/

FFmpeg WebAssembly
WebAssembly에서 제공하는 브라우저 및 노드용 FFmpeg
ffmpeg.wasm은 FFmpeg의 순수한 Webassembly/Javascript 포트입니다. 그것은 비디오 및 오디오 녹음, 변환, 스트리밍 등을 브라우저 내부에서 할 수 있도록 합니다.
FFmpeg WebAssembly를 사용하는 이유는 FFmpeg를 사용해서 브라우저로 하여금 비디오 파일을 변환하기 위함이다.
npm install @ffmpeg/ffmpeg @ffmpeg/core
https://github.com/ffmpegwasm/ffmpeg.wasm
https://www.npmjs.com/package/@ffmpeg/ffmpeg

WebAssembly
WebAssembly(Wasm)는 스택 기반 가상 머신을 위한 이진 명령 형식입니다. Wasm은 프로그래밍 언어를 위한 이식 가능한 컴파일 대상으로 설계되어 클라이언트 및 서버 응용 프로그램을 위해 웹에 배포할 수 있습니다.

웹 어셈블리는 자바스크립트의 무덤일까?
https://www.youtube.com/watch?v=KjgDxBLv0bM

맥에서 FFMpeg설치하기
brew install ffmpeg

#14.1

1. http://localhost:4000/node_modules/@ffmpeg/core/dist/ffmpeg-core.js 404 (Not Found) 또는
createFFmpegCore is not defined 오류 해결 방법
(@ffmpeg/ffmpeg": "^0.10.0 이상으로 진행시)

위와 같은 오류가 뜨시는 분들은 http://localhost:3000/node_modules/@ffmpeg/core/dist/에서 ffmpeg-core.js, ffmpeg-core.wasm, ffmpeg-core.worker.js파일들을 찾지 못해 생기는 에러이기 때문에 아래와 같이 corePath를 지정해주시면 됩니다.
https://github.com/ffmpegwasm/ffmpeg.wasm#why-it-doesnt-work-in-my-local-environment
```
createFFmpeg({
corePath: 'https://unpkg.com/@ffmpeg/core@0.10.0/dist/ffmpeg-core.js',
log: true
});
```

(위의 1번 다른 해결 방법)
기존 FFmpeg를 삭제하시고, 다운그레이드된 버전으로 설치하시면 됩니다.
npm i @ffmpeg/ffmpeg@0.9.7 @ffmpeg/core@0.8.5

2. Uncaught (in promise) ReferenceError: SharedArrayBuffer is not defined 오류 해결 방법
FFmpeg를 실행했을 때, 콘솔창에 위와 같은 오류가 난다면 server.js에 app.set()아래에 함수를 추가해주시면 됩니다.

오류 원인 : SharedArrayBuffer는 cross-origin isolated된 페이지에서만 사용할 수 있습니다. 따라서 ffmpeg.wasm을 사용하려면 Cross-Origin-Embedder-Policy: require-corp 및 Cross-Origin-Opener-Policy: same-origin를 header에 설정해 자체 서버를 호스팅해야 합니다.
https://github.com/ffmpegwasm/ffmpeg.wasm/issues/263

// server.js
```
app.use((req, res, next) => {
res.header("Cross-Origin-Embedder-Policy", "require-corp");
res.header("Cross-Origin-Opener-Policy", "same-origin");
next();
});
```

FFmpeg Usage
https://github.com/ffmpegwasm/ffmpeg.wasm#usage

FFmpeg API
https://github.com/ffmpegwasm/ffmpeg.wasm/blob/master/docs/api.md#api

#14.2

MEMFS에서 데이터 읽기
ffmpeg.FS('readFile', 'video.mp4');
https://github.com/ffmpegwasm/ffmpeg.wasm/blob/master/docs/api.md#ffmpegfsmethod-args-any

Uint8Array (양의 정수 8비트 배열)
Uint8Array 형식 배열은 8비트 부호 없는 정수 배열을 나타냅니다.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array

ArrayBuffer
ArrayBuffer 객체는 raw binary data buffer를 나타내는 데 사용됩니다. 다른 언어에서는 종종 "byte array"이라고 하는 byte array입니다.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer

Blob
Blob 객체는 파일류의 불변하는 미가공 데이터를 나타냅니다. 텍스트와 이진 데이터의 형태로 읽을 수 있으며, ReadableStream으로 변환한 후 그 메서드를 사용해 데이터를 처리할 수도 있습니다.
https://developer.mozilla.org/ko/docs/Web/API/Blob

#14.3
Thumbnail

You can extract images from a video, or create a video from many images
비디오에서 이미지를 추출하거나 여러 이미지에서 비디오를 만들 수 있습니다. 이것은 비디오에서 초당 하나의 비디오 프레임을 추출하고 foo-001.jpeg, foo-002.jpeg 등의 파일로 출력합니다. 이미지는 새로운 WxH 값에 맞게 크기가 조정됩니다. 제한된 수의 프레임만 추출하려면 위의 명령을 -frames:v 또는 -t 옵션과 함께 사용하거나 -ss와 함께 사용하여 특정 시점부터 추출을 시작할 수 있습니다.
ffmpeg -i foo.avi -r 1 -s WxH -f image2 foo-%03d.jpeg
https://www.ffmpeg.org/ffmpeg.html

Blob()
Blob() 생성자는 새로운 Blob 객체를 반환합니다. 해당 블롭의 콘텐츠는 매개변수로 제공한 배열을 이어붙인 값입니다.
var aBlob = new Blob( array[, options]);
array는 ArrayBuffer, ArrayBufferView (en-US), Blob, DOMString 객체 또는 Blob 안에 들어갈 이러한 객체가 혼합되어 있다. DOMString은 UTF-8로 인코딩 된다.
```
var oMyBlob = new Blob(aFileParts, {type : 'text/html'}); // the blob
```
https://developer.mozilla.org/ko/docs/Web/API/Blob/Blob

#14.4

메모리 관리를 위해 다쓰고 링크와 파일을 삭제해줘야

MEMFS에서 파일 삭제
ffmpeg.FS('unlink', 'video.mp4');
https://github.com/ffmpegwasm/ffmpeg.wasm/blob/master/docs/api.md#ffmpegfsmethod-args-any

FFMpeg 비디오, 오디오 파일 포맷 컨벤션
https://ffmpeg.org/ffmpeg.html#Video-and-Audio-file-format-conversion

URL.revokeObjectURL()
URL.revokeObjectURL() 정적 메서드는 이전에 URL.createObjectURL()을 통해 생성한 객체 URL을 해제합니다. 객체 URL을 더는 쓸 일이 없을 때 사용해서, 브라우저가 이제 해당 객체를 메모리에 들고 있지 않아도 된다고 알려주세요.
```
URL.revokeObjectURL(objectURL)
objectURL: createObjectURL()을 통해 생성한 객체 URL을 나타내는 DOMString.
```
https://developer.mozilla.org/ko/docs/Web/API/URL/revokeObjectURL

#14.6

Multer에서 파일을 2개이상 올릴때는 single과는 다른 메서드를 쓴다.

Multer
.fields(fields)
필드로 지정된 혼합 파일을 허용합니다.
파일 배열이 있는 객체는 req.files에 저장됩니다.
필드는 이름과 선택적으로 maxCount가 있는 객체의 배열이어야 합니다.

예시
```
[
{ name: 'avatar', maxCount: 1 },
{ name: 'gallery', maxCount: 8 }
]
```
https://www.npmjs.com/package/multer

video 태그 poster 속성
video 태그의 poster 속성은 비디오를 다운로드하는 동안이나 사용자가 재생 버튼을 누르기 전까지 비디오 대신 보여줄 이미지를 명시합니다.
만약 poster 속성이 명시되어 있지 않으면, 브라우저는 비디오의 첫 번째 프레임(frame)을 대신 보여줄 것입니다.
video poster="URL"
http://tcpschool.com/html-tag-attrs/video-poster

#15.0

Express Flash
Express 애플리케이션용 플래시 메시지
플래시는 플래시 메시지를 정의하고 요청을 리디렉션하지 않고 렌더링할 수 있는 기능이 있는 connect-flash의 확장입니다.
npm i express-flash

사용 예시
```
app.get('/', function (req, res) {
req.flash('info', 'Welcome');
res.render('index', {
title: 'Home'
})
});
app.get('/addFlash', function (req, res) {
req.flash('info', 'Flash Message Added');
res.redirect('/');
});
```
https://www.npmjs.com/package/express-flash

connect-flash
https://www.npmjs.com/package/connect-flash

#16.3
fetch()를 이용해서 데이터 보내기
fetch() request에 포함할 수 있는 또 다른 선택적 속성은 body입니다. body 속성은 HTTP(또는 API) request의 일부로, 보내려는 모든 데이터를 포함할 수 있습니다. API request를 할 때, 데이터가 포함된 헤더와 함께 전송됩니다. fetch()를 사용하여 데이터를 보낼 때 보낸 데이터가 JSON인지 쿼리 문자열인지 API에 알려주는 Content-type을 지정해야 합니다.
https://gomakethings.com/how-to-send-data-to-an-api-with-the-vanilla-js-fetch-method/

fetch()를 이용해서 JSON객체 보내기
https://gomakethings.com/how-to-send-data-to-an-api-with-the-vanilla-js-fetch-method/#sending-data-as-a-json-object

댓글창에서 스페이스를 눌렀을 때 비디오도 같이 재생되는 문제 해결 방법
```
const handlePressSpace = async (event) => {
if (event.target === document.body && event.code === "Space") {
await handlePlayVideo();
}
};

#16.4

express.text([options])
Express에 내장된 미들웨어 기능입니다.
body-parser를 기반으로 request payload로 전달한 문자열을 파싱합니다.
https://expressjs.com/ko/api.html#express.text

express.json([options])
Express에 내장된 미들웨어 기능입니다.
body-parser를 기반으로 request payload로 전달한 JSON을 파싱합니다.
문자열을 받아서 json으로 바꿔줍니다.
주의할 점은 express.json()은 header에 Content-Type이 express.json()의 기본 값인 "application/json"과 일치하는 request만 보는 미들웨어를 반환합니다.
다시 말해, headers: { "Content-type": "application/json" }인 request만 express.json()을 실행한다.
https://expressjs.com/ko/api.html#express.json

fetch()를 이용해서 JSON객체 보내기
https://gomakethings.com/how-to-send-data-to-an-api-with-the-vanilla-js-fetch-method/#sending-data-as-a-json-object

#16.5

request 가 발생할때 from frontend to backend,
 쿠키도 같이 간다 => 백엔드에서 세션을 쓸수있다.
 =>세션에는 user정보도 들어가있다.

HTTP 상태 코드

200 OK
요청이 성공적으로 되었습니다.

201 Created
요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었습니다. 이 응답은 일반적으로 POST 요청 또는 일부 PUT 요청 이후에 따라옵니다.

400 Bad Request
이 응답은 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미합니다.

404 Not Found
서버는 요청받은 리소스를 찾을 수 없습니다. 브라우저에서는 알려지지 않은 URL을 의미합니다.

https://developer.mozilla.org/ko/docs/Web/HTTP/Status

#16.6

다중 경로 populating하기 (Populating Multiple Paths)
(비디오 안에 댓글 안에 유저 또는 비디오를 찾을 때 사용 가능)
```
// 방법1: populate를 배열로 감싸고 그 안에 컬렉션을 전달
Manager.find()
.populate({
path : 'users',
populate: [
{ path: 'cars' },
{ path: 'houses' }
]
});

// 방법2: 공백으로 구분된 컬렉션 문자열을 전달
Manager.find()
.populate({
path : 'users',
populate: 'cars houses'
});
```

유저가 작성한 댓글 DB에 저장하기
```
const foundUser = await User.findById({ _id: loggedInUser._id }).populate("comments");

if (!foundUser) {
return res.sendStatus(404);
}

const createdComment = await Comment.create({ owner: loggedInUser._id, video: id, text });
foundUser.comments.push(createdComment);
foundUser.save();
```

Location.reload()
Location.reload() 메서드는 새로고침 버튼처럼 현재 리소스를 다시 불러옵니다. 새로고침은 SECURITY_ERROR DOMException (en-US)과 함께 거부당할 수 있습니다. 이는 location.reload()를 호출한 스크립트의 출처와 Location 객체를 소유한 문서의 출처가 다를 때 발생합니다.
window.location.reload()
https://developer.mozilla.org/ko/docs/Web/API/Location/reload

#16.7

append 마지막에 붙임
prepend 처음에 붙임

#16.8

res.json([body])
JSON response를 보냅니다. 이 메서드는 JSON.stringify()를 사용하여 JSON 문자열로 변환된 매개변수인 response를 보냅니다.

사용 예시
```
res.json(null)
res.json({ user: 'tobi' })
res.status(500).json({ error: 'message' })
res.status(201).send({ hello: 'message' }) // res.send()로도 가능
```
https://expressjs.com/ko/api.html#res.json

Response.json()
Response 인터페이스의 json() 메서드는 Response 스트림을 가져와 읽습니다.
(백엔드의 res.json() 또는 res.send()를 통해 보낸 JSON데이터를 가져온다.)
https://developer.mozilla.org/en-US/docs/Web/API/Response/json

HTTP Method 종류와 의미들 올려둡니다.

주요 메소드 5가지

GET : 리소스 조회
POST : 요청 데이터 처리, 주로 데이터 등록에 사용
PUT : 리소스를 대체, 해당 리소스가 없으면 생성
PATCH : 리소스를 일부만 변경
DELETE : 리소스 삭제
기타 메소드 4가지

HEAD: GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
OPTIONS: 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

출처 : https://kyun2da.dev/CS/http-%EB%A9%94%EC%86%8C%EB%93%9C%EC%99%80-%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C/

#16.9

챌린지 과제
- 댓글 삭제하기 (삭제시 비디오나 유저 도큐먼트에서도 삭제 필요)

추가로 구현해볼 만한 기능들
- 댓글 추가 및 삭제시 실시간으로 댓글 갯수 변경
- 댓글 수정하기
- 좋아요
- 좋아요 취소
- 해시태그 클릭시 비디오 찾기

Element.remove()
Element.remove() 메서드는 해당 요소가 속한 트리에서 요소를 제거합니다.
(remove대신 removeChild를 사용해서 엘리먼트 삭제도 가능)
https://developer.mozilla.org/en-US/docs/Web/API/Element/remove

querySelectorAll => 댓글들 개개마다 클래스를주고, 선택댓글을 삭제해야하니
모든 엘레멘트를 선택해야.
deleteCommentBtns.forEach((delteBtn)=>{
    delteBtn.addEventListener("click", handleDelete);    
  });
이벤트리스너 또한 모든 엘레멘트 클릭이벤트에 대해 듣고있어야하니 forEach로 돌려준다.

const comment = event.target.parentNode;
  => event.target은 이벤트가일어난 그엘레멘트이고, .parentNode는 그 엘레멘트의 부모엘레멘트.
  
#17.0

Building the Backend

babel-node는 개발용, 실행에 시간이좀걸림
  =>배포용으로 구식 자바스크립트 코드로 해야하는데
babel/cli을 쓴다.

@babel/cli 설치
npm install --save-dev @babel/cli
Babel은 명령줄에서 파일을 컴파일하는 데 사용할 수 있는 내장 CLI와 함께 제공됩니다.
https://babeljs.io/docs/en/babel-cli

폴더 컴파일
--out-dir 또는 -d 사용 가능
```
npx babel src --out-dir lib
```
https://babeljs.io/docs/en/babel-cli#compile-directories

#17.1

regeneratorRuntime
Regenerator로 컴파일된 생성기 및 비동기 함수를 위한 독립 실행형 런타임입니다.

// init.js
```
import "regenerator-runtime";
```
https://www.npmjs.com/package/regenerator-runtime

#17.2

Building the Frontend

Webpack Mode 설정 (두 가지 방법)
```
// 1. webpack.config.js 파일에 mode옵션을 설정하거나
module.exports = { mode: 'development' };

// 2. 또는 package.json script에 CLI 인수로 mode설정
webpack --mode=development
```
주의! 만약 Mode를 설정하지 않으면 webpack은 production(배포)를 모드의 기본값으로 설정합니다.
https://webpack.js.org/configuration/mode


Babel로 컴파일시 파일이나 폴더 무시
build:server를 할 때 포함되는 client 폴더는 필요하지 않기 때문에 아래와 같이 ignore해주시면 됩니다.
```
npx babel src --out-dir lib --ignore "src/client"
```
https://babeljs.io/docs/en/babel-cli#ignore-files

#17.3

Heroku
https://www.heroku.com

heroku logs --tail: 실시간으로 헤로쿠 로그 보기

Heroku로 배포하기

1. Heroku CLI 이용하기
heroku login (헤로쿠 로그인)
heroku git:remote -a app이름 (헤로쿠 원격 저장소와 연결)
git push heroku master (헤로쿠에 푸시)

2. GitHub 이용하기

MongoDB Atlas
https://www.mongodb.com/cloud/atlas

+ mode를 production으로 했음에도 코드가 한 줄로 축약되지 않으시는 분들은 optimization 옵션을 제거해주시면 됩니다.

#17.4

MongoDB Atlas
https://www.mongodb.com/atlas/database

MongoDB 생성
1. 새로운 Project 생성
2. Cluster추가 (Create a database)
(Atlas-DEPLOYMENT-Databases에서 Build a Database로 변경)
3. Shared클릭
4. Cloud Provider & Region 선택 (us-east-1)
5. Cluster Tier 선택 (Free)
6. Cluster 생성

Connect to DB
password를 사용자의 암호로 바꿉니다. myFirstDatabase를 연결이 기본적으로 사용할 데이터베이스 이름으로 바꿉니다. 모든 옵션 매개변수가 URL로 인코딩되었는지 확인하십시오.

.env에서 설정한 환경 변수를 heroku에 Config Vars에 추가

#17.5
환경변수들은 heroku에서 설정해줘야한다.
깃허브 로그인관련 GH_CLIENT, GH_SECRET또한 마찬가지

#17.6

GitHub Developer settings (깃허브 소셜 로그인 구현시)
생성한 OAuth Apps의 Authorization callback URL를 최종 배포한 사이트 주소로 변경
https://github.com/settings/developers

Kakao Developer settings (카카오 소셜 로그인 구현시)
깃허브와 동일하게 Redirect URL 변경 필요
https://developers.kakao.com/console/app