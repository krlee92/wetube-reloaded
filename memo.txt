# 2.1 Installing Express
(1) node js파일명 --> 이 방법으로도 js파일을 실행시킬 수 있다
(2) 이번 프로젝트에서는 package.json으로 실행 해 줄것이다
(3) package.json 안에 main --> 내가 만들고 배포한 package를 다른 사람들이 설치하면 main을 사용한다(이번 프로젝트에서는 필요없음)
(4) package.json 안에 scripts를 만들어 준다
(5) scripts 는 실행하고 싶을 것을 말한다 즉, scripts안에 실행할 것을 적어준다
ex) scripts={
"start": "node index.js" // 이름은 자유롭게 지어줄 수 있다
}
(6) 그 후 npm run start 로 실행시킬 수 있다 // package.json이 존재하는 폴더 한정
(7) npm install express 로 Express 패키지를 다운로드 받는다
(8) node_modules, package-lock.json 파일이 생성도니다
(9) node_modules 에는 npm으로 설치한 모든 패키지가 저장된다
(10) express 는 혼자 작동되지 않기에 다른 패키지가 필요하다
(11) node_modules 안에 express 안에 존재하는 package.json안에 dependencies는 express가 작동되기위해 필요한 패키지들을 나타낸다
(12) express를 설치하는데 의존하고 있는 패키지가 있기 때문에 npm i express를 하면 그것들도 함께 설치된다
(13) npm i express 를 했을 때 npm 이 알아서 dependencies에 express를 추가해준다

#2.2
npm i express
- Created node_modules and package-lock.json and we deleted them
- We're going to install express again but now we are not going to run npm i express
-- We're going to run "npm i" only => We have node_modules and package.json again
--> npm is very smart and it looks at your package.json and finds there is a dependencies entry. And it looks at the dependencies and npm installs them for you
--> package.json is important b/c now it stores the info that our project needs to run
- Very good b/c when you're working on a NodeJS project with a team or changing computers
-- You do not want to upload node_modules to your GitHub
-- node_modules can get super heavy
-- If you want to give to your friend, all you have to do is copy package.json and index.js and that's it. You don't have to copy node_modules
- package-lock: keeps your packages very secure
-- Checks packages haven't been modified and checks with a hash --> really safe
-- Basically locked
-- Important b/c if my project works with package-lock and package.json, when your friend installs express again from the package.json, if you give package.json, package-lock.json, and index.js to your friend, and they run "npm i" only. Then, you're going to be sure that they got the exact same version number on everything.
--> Very useful b/c that means your code is going to run for sure
- We want to be very precise with the version numbers in package-lock.json
-- But we don't have to manage any of this. This is done automatically for us by npm
.gitignore file: Hide your node_modules from your GitHub
- Add "/node_modules"
Reason why you should close package.json
- Some people have trouble when they do "npm i"
- b/c if your package.json is open and you haven't saved and you run "npm i express"
=> npm is going to modify your package.json b/c npm is going to try to add dependencies to pacakge.json
- But b/c you haven't saved, there will be like a conflict on versions
--> Every time you're going to run "npm install", make sure that you close or save your package.json
Remember: Dependencies are what makes your project run
- And you don't have to send your friend the node_modules folder

# 2.3
NodeJS에서 필요한 babel설치
npm install --save-dev @babel/core
npm install @babel/preset-env --save-dev

babel.config.json파일 생성
```
{
"presets": ["@babel/preset-env"]
}
```
https://babeljs.io/setup#installation

@babel/preset-env
@babel/preset-env는 환경에 필요한 구문 변환을 세부적으로 관리할 필요 없이 최신 JavaScript를 사용할 수 있게 해주는 스마트한 preset입니다.
https://babeljs.io/docs/en/babel-preset-env

dependencies = 프로젝트에 필요한것들 다운(필수)
devDependencies = 프로그래머가 더 편하게 코드를 짤수있게 도와주는 보조툴(보조)

#2.4
//nodeJS가 이해하는 코드를 쓰거나 babel을 사용한다.
// babel은 우리가 작성한 최신 자바스크립트를 컴파일 해준다.
// 이 말은 nodeJS가 자바스크립트를 문제없이 이해하도록 변환해준다는 뜻이다.
// pacakge.json은 텍스트 파일인데 devDependencies는 개발자가 필요한 설정인데
dependencies는 무슨 프로젝트를 사용할 지 알려주는데 devDependencies는
 프로젝트를 실행하기 위한 dependencies로 자동차로 따지면 가솔린과 같은 존재이다. 
 devDependencies는 내가 운전을 더 잘하려면 음악이 있어야 하는 것과 비슷하다.
  하나는 개발자에게, 다른 하나는 프로젝트 필요한 것으로 개발자에게 babel이 필요하다. 
  babel이 devDependencies에 들어가면 모든 건 node_modules에 들어가므로 npm install --save-dev @babel/core에서
   --save-dev를 지우고 npm install @babel/core를 사용하면 된다. 다른 곳에 생긴다면 그냥 옮기면 된다.
    babel.config.json configuration file을 사용하면 된다.
     꼭, package.json 파일을 닫거나 저장되어 있는지 확인해야한다.
      babel을 이용해서 최신 문법 코드를 쓸 수 있는데 babel을 설정해 줄 필요가 있다.
       babel.config.json을 만들면 babel이 알아서 이 파일을 찾고 내용을 들여다 본다.
        presets은 babel을 위한 엄청 거대한 플러그인인데 preset-env가 가장 유명하다.
         smart preset을 사용하면 최신 자바스크립트 문법을 사용할 수 있다.
          preset에는 종류가 엄청 많은데, 그 중에 babel/preset-react, babel/preset-typescript 등을 사용할 수 있다.
           preset은 플러그인을 알면 되는데 preset-env는 최신 자바스크립트를 쓸 수 있다.
            babel.config.json 파일을 만들어서 내용을 붙여넣기 하면 되는데 @babel/core와 @bable/preset-env를 설정해야 한다.

#3.0
Make a src folder and all my application (the ones that have code and all the logic: index.js currently) is going to live inside of src
=> Change package.json:
"scripts": {
"dev": "nodemon --exec babel-node src/index.js"
},

The file name doesn't have to be named index.js
- For this, change to server.js and change package.json:
"scripts": {
"dev": "nodemon --exec babel-node src/server.js"
},

=> In server.js:
import express from "express"; // import the package called express from "express"
- NodeJS and npm are so smart that they know that when I do this, I'm looking for express in the node_modules
--> So you don't need to say node_modules/express
- npm and NodeJS are going to search for express in node_modules until they find it and they are going to call index.js
- You don't need to worry node_modules b/c you're not going to write this anywhere in your life

How do we use express:
1) Create an express application
const app = express();
2) Now your application needs to listen
- What is a server?
-- A server is a computer that is always online
-- Most of the time, it doesn't even have a screen or keyboard
-- It's listening to request
--- Request: just a connection
-- You send a message to the server, and the server sends that message to me --> Request
-- Server listens and responses
-- We need to make the server wait for people to ask for stuff
--> `app.listen()`
-- listen() has a callback
--- callback here: the function that will happen when our server starts
--- Before writing the callback, first we need to tell the server what port the server is going to be listening to
---- b/c your computer has many ports
---- port: like a door or window into your computer
---- some ports are open to the Internet

Our server is going to be listening to our port
- The high number ports are always available
app.listen({port number}, callbackFunc); --> we use 4000 as the port number here (not required)

How to go to a server
- When you start a server in your computer, usually that server can be accessed through localhost
http://localhost:4000/

To kill your server and nodemon: ctrl/command + c
- When you kill the server, the localhost refused to connect

import express from "express";

const PORT = 4000;

const app = express();

const handleListening = () =>
console.log(`✅ Server listening on port http://localhost:${PORT} 🚀`);

app.listen(PORT, handleListening);

#3.1
1. Once you create a server, you need to make server respond to user requests.
2. Users request using HTTP protocol. This request is called GET request.
3. When they type in the URL in the address bar and the page loads, they are actually sending a GET request to a server, getting a response and displaying a response on the browser.
I hope this helps and I wish you guys the best! :)

#3.2
1. In order to make a server respond to a GET request from a user's browser, set up .get() that takes in a "home URL" and "eventHandler function" as below:
const handleHome = () => console.log("Somebody is trying to go home.");
app.get("/", handleHome);
2. Having these codes in a server.js (has to placed after express server initiates), it will know how to respond to GET requests from users. However, since EventHandler does not return anything, it will keep the browser loading, waiting for a response from the server.
I hope this helps! God bless you all! :)

#3.3
1. Though setting up .get("URL", "GET handler function") will handle a Get request, it will not respond to a GET reqeust.
2. In order to make a server respond to a user's GET request, you need to modify the EventHandler function into an arrow function. Then, make the response argument .end() or .send() as below:
const handleHome = (req, res) => {
return res.send("I still love you.");
};
3. The first argument inside GET handler function is usually named "req," it takes in a request object.
4. The second argument is usually named "res," and it takes in a response object.
5. res.end() will end the response without returning anything; res.send() will return an input to the user's browser. For this particular example, the user will see a string "I still love you." on their browser when they request for a home ("/") URL page to a server.
I hope this helps! Good luck to you all! :)

#3.4
app.get(path, callback [, callback ...])
지정된 콜백 함수를 사용하여 HTTP GET 요청을 지정된 경로로 라우팅합니다.

Request
req 객체는 HTTP request를 나타내며 요청 query string, parameters, body, HTTP headers 등에 대한 속성을 가지고 있습니다.

Response
res 객체는 Express 앱이 HTTP request를 받을 때 보내는 HTTP response를 나타냅니다.

https://expressjs.com/ko/4x/api.html#express.json

#3.5
-middleware는 reqeust,response 사이에있는 소프트웨어이다.
-모든 controller,handler는 middleware이다.
-middleware에는 controller와같은 2개의 argument외에 한개가 더있다. req, res, 그리고 next
 next();를호출하여 다음 메소드를 실행시키는것이 middleware이다.
 middleware는 절대로 req에대해 response하지않는다.
 ->return은 response한뒤 서버 연결을 끊기때문이다.

#3.7
setup Recap
pacakge.json = scripts안에 실행어를 저장하여 편하게 실행
dependencies,devDependencies = 필요한 툴들을 저장하여
node_modules에 저장하게 도와줌. 실행어는 npm i

devDependencies
 -nodemon => 저장시 변화가있을때 scripts 커맨드를 자동실행
 -bable-node => ES6등 최신코드를 쓰고싶을때 node.js가 이해할수있게 JavaScript를 바꿔줌
  bable.config.json => babe-node를 쓸때 만들어서 필요한 플러그인 정보를 넣음.


#3.8
Server Recap
-Server : request를 listening하고있는 컴퓨터
클라이언트와 서버는 개방된 포트를 통해 request 와 response 를 주고받는다.
 ->브라우저는 서버에게 페이지를 request한다(페이지를 get한다).
 get request에 반응하기위해서는
 app.get("/", handleHome); "/"를 라우터라고 한다.

#3.9
controller Recap
HTTP request 는 어떤 route(url) 에 대한 HTTP Method 요청이고 서버는 그 요청에 대한 response 를 해주어야한다. 여기서 중요한 것이 또 **controller**이다.
# controller
컨트롤러는 전달받은 request를 처리하고 response를 전달하기 위한 콜백함수이다.
request가 왔으면 response해줘야 한다.
controller는 항상 req,res를 아규먼트로 가진다.
req,res에는 많은 메소드가 있다.
 ->res.send()나 res.end() 등으로 respond해줘야한다.

#3.10
middleware
 request와 response의 중간에 있는 소프트웨어이다.
 app.get("/",middleware, handleHome)
 미들웨어는 request 오브젝트와, response 오브젝트 말고도 next 파라미터를 갖는다.
 next 파라미터는 다음으로 request 를 처리할 콜백함수를 담고있다.
미들웨어를 글로벌하게 사용하는법
app.use(미들웨어1,미들웨어2...)를 만들어 get("/", ...)보다 위에 둔다.

#3.11
morgan
 -morgan 패키지는 node.js 서버로 구성된 웹 환경에서
  HTTP request 로그를 관리하기 위한 미들웨어이다.
npm i morgan으로 설치한후
import morgan from "morgan"으로 부른후 사용한다.
 ->사용법은 app.use(morgan("dev..")) 등으로
 morgan()이 미들웨어를 return해준다. 아규먼트는 5종류있다.

#4.0
라우터
 라우터는 url이 어떻게 시작하는지에 따라 나누는 방법
 라우터는 작업중인 주제를 기반으로 URL을 그룹화한다
 /users/edit -> Edit user
 /videos/watch -> Watch Video

#4.1
 라우터의 그룹화 규칙에 따르면 로그인페이지는 
 /users/login이어야 한다. 유저가 로그인하기때문이다.
 하지만 때때로 편의성을위해 예외를 두기도한다.
 /login이 더 깔끔하기 때문이다.

** 유저의 req-> 서버 res 흐름
유저가 /videos로 시작하는 url에 들어가면
express는 video라우터에 들어가서, url의 나머지주소를 찾는다.

#4.2
server.js에 라우터를 다 모아놓으면 보기안좋으니 정리한다.
global,user,video라우터 각 3개의 폴더로 나눈다.
그럼 server.js에서 각 라우터를 못찾을텐데 각각을 import해줘야한다.
 프로젝트에 있는 모든 파일은 분리된 모듈이다.
 다른 파일에서 쓸때는 그 파일에서 export, 쓸파일에서 import해야한다.

#4.3
 라우터와 컨트롤러를 같은파일에 쓰는것은 좋지않다.
 컨트롤러는 많은 데이터를 가져와 처리할것이고 양이 방대해질것이기 때문
 따라서 컨트롤러 폴더/파일을 따로 만들어 관리하자.

export
 -> default export한것을 import할때 지정하는 이름은 같지않아도 됀다
 하지만 개별을 export할때는 반드시 서로 같아야 한다.
 ->중괄호 열고 { edit, remove, ...}등 불러올것을 똑같이 적어넣어 오브젝트화시킨다.
 ** 경로지정 규칙
 ../ 지금있는 폴더에서 벗어남
 ./ 지금있는 장소

 #4.7
 URL parameters
 videoRouter.get("/:id", see);
 /:id에서 :은 뒤에오는 id가 파라메터(변수)라고 express에게 알려준다.
 그 파라메터는 컨트롤러에서 req.params.id로 유저의 리퀘스트중 파라메터값이 무엇인지 확인가능.

 **비디오 라우터에서
  videoRouter.get("/upload", upload);
  videoRouter.get("/:id", see);
  videoRouter.get("/:id/edit", edit);
  처럼 upload를 맨위로 올리는 이유가 있다.
  express는 위에서부터 아래로 체크하기때문에, 만약 
  videoRouter.get("/:id", see);
  videoRouter.get("/upload", upload);
  videoRouter.get("/:id/edit", edit);
  이순서이고, 유저가 videos/upload로 request를 보내면
  express는 :id를 먼저보고 /upload를 파라메터로 취급하게됀다.
  =>이것의 해결을위해 express 정규식을 사용한다.
  정규식을 사용하여 파라메터에 숫자만 올수있게 하는것이다.

#4.8
URL parameters 정규식
  Routing
  https://expressjs.com/ko/guide/routing.html
  정규표현식 테스트 사이트
  https://www.regexpal.com
  정규식 표현 정리글
  https://kasterra.github.io/regex1-the-basic-operation/

  \w+: 모든 문자, 숫자 선택
  \d+: 모든 숫자 선택

#5.1

**
pug사용에대한 의문
res.sendFile(__dirname, 'potato.html') 같이 html 파일을 바로 렌더링 할 수 있긴 합니다.
하지만 request를 통해 각종 변수를 전달하지 못하기 때문에 미리 정해둔 화면 밖에는 보여줄 수가 없고,
header 나 footer 등을 따로 partial로 만들어 관리하고 모든 파일에 첨부한다든지 할 수 있기 때문에 pug를 쓰는 것입니다.
또한 pug외에도 ejs등 다른 template engine도 있습니다. 저는 써 본 것 중에서는 pug가 제일 깔끔하고 좋은 것 같네요.
그리고 아예 react등의 framework를 사용하시면 템플릿 엔진 없이 view부분을 만드실 수 있습니다.

pug사용
send에 html을 보내기는 힘들다.
pug를 사용하면 편하다.
 1) 깔끔한 html작성을 도와준다(닫지않아도됀다)
 2) html에 자바스클비트 코드를 포함시킬수있다.
 3) 반복이 있으면 partials폴더를 만들어 그곳에 반복파일을 만들고
 html내에서 include 시키면됀다
따라서 그걸 도와주는 pug를 설치한다 npm i pug
->server.js에서 app.set("view engine", "pug")을 통해
view엔진이 pug라는걸 express에 알려준다.
**
헤더에서 Express를 없애는 방법:
app.disable('x-powered-by');
->views폴더에 pug파일을 만든다.

**
디폴트로 express는 cwd + /views에서 pug 파일을 찾는다.
cwd(current working directory)는 node.js를 실행하는 pacakge.json이 있는 디렉토리이므로
현재 프로젝트는wetube/가 cwd이다.
현 프로젝트에 views폴더는 wetube/src/안에 있기때문에 디폴트 view경로를 바꾼다.
app.set("views", process.cwd() + "/src/views")으로 경로를 바꿀수있다.

#5.3
block기능
 상속을 해줄 base.pug파일에서 block을 만들어놓으면
 상속받는 파일에서 block안 내용을 채울수 있다.
include기능
 base.pug파일에서 include로 내용을추가해놓으면 모든 상속받는 파일에서
 그 내용이 적용됀다.
Pug는 템플릿 상속을 지원합니다. 템플릿 상속은 block과 extends키워드를 통해 사용합니다.
템플릿의 block에는 하위 템플릿을 대체할 수 있습니다.
**
ENOENT: no such file or directory, open '/home/ndm02002/wetube/src/views/base.pug'
base 파일을 view 아래에 놓아야 됨 ㅠ

#5.4
변수variables 사용
컨트롤러에서 변수를 같이 보내면, 그 변수를 pug에서도 사용할수있다.
컨트롤러 => res.render("home", { pageTitle: "Home" });
base.pug => title #{pageTitle} | Wetube

#5.5
pug recap
1) 파이썬처럼 깔끔한 코드를 쓸수있다.
  태그를 닫는것 x
  모두 탭과 띄어쓰기로 구분됀다.
2) express가 랜더링 할수있다.
  app.set으로 어디서찾는지 설정해준뒤
  res.render("pug파일명)
3) include : 상속받는 모든파일에서 공통적으로 나타낼때

4) base.pug 기본구조를 만들어 다른파일에서 똑같이 상속받을때
block기능으로 상속받는 파일들이 블록 내용을 채워넣을수있다.

5) variable
자바스크립트 코드를 #{}로 쓸수있다.
이때 변수도 쓸수있는데, 컨트롤러에서 랜더링할때 변수를 같이 보내주면
그 변수를 pug파일에서 사용가능하다.

#5.6
MVP Styles
모든 html element를 이쁘게 만들어주는
link(rel="stylesheet" href="https://unpkg.com/mvp.css")를 헤드에 추가

#5.7
pug에서 변수를 대입할때 2가지방법
title #{pageTitle} Wetube
title = pageTitle =>한개의 변수외에 텍스트가없을때.

pug에서도 조건문을 쓸수있다 if/else
if 조건
  실행식
else
  실행식

#5.8
Iteration
  elements의 list를 보여주는것
Iteration (반복)

Pug는 each와 while라는 두 가지 기본 반복 방법을 지원합니다.
```
ul
each val(아무이름가능) in [1, 2, 3, 4, 5](컨트롤러에서 보내준 변수명이랑 같아야)
li= val
```

**
배열이나 객체에 반복할 값이 없으면 실행될 else 블록을 추가할 수도 있습니다.
```
- var values = [];
ul
each val in values
li= val
else
li There are no values
```
https://pugjs.org/language/iteration.html

#5.9
mixin
=> partial과 유사한 데이터를 받을수있는 미리 만들어진 HTML block이다.
사용
1)mixins폴더에 mixin파일명.pug를 만들어주고 내용을 작성한다.
2)mixin이 필요한 곳에서 include mixins/video(파일명)으로 인클루드 해준다.
3)사용이 필요한 위치에서 +파일명(변수명) 넣어준다
    each potato in videos
        +video(potato)
    else
        li Sorry nothing found.
자세히는
https://pugjs.org/language/mixins.html

#5.10
Iteration mixin recap
Iteration은 array의 모든 element에 대해 특정 행동을 할때 씀
mixin은 partial과 유사하게 반복해서 쓰지만
데이터도 받아 쓸수있는것이 다르다.

#6.0
POST

pug에서 변수variable을 쓰는방법은 =, #{} 두개가 있다고
위에서 배웠지만 attribute에는 쓸수없다.
attribute에서 변수를 쓰는방법은 `${}` 혹은 + video.id 로 두가지이다.

**ES6
const { id } = req.params;
const id = req.params.id;

#6.1

absoulte(/) relative URL 절대 상대
현재 경로가 localhost:4000/video/edit인데
a(href="/potato")이면 =>localhost:4000/potato로(absoulte)
a(href="potato")이면 =>localhost:4000/video/potato로(relative)

#6.2
POST
form(action="")의 action에는 submit을 누르면 데이터가 가게될곳을 적는다.
디폴트 전송방식은 get이다(method="GET") POST로 바꿔주면 POST전송이됀다.
POST를 쓰려면 라우터에서도 POST로 받아줘야한다.

method는 form과 back end 사이의 정보 전송 방식이다.
전송하는 데이터로 backend에서 database의 정보를 수정,추가,삭제..등을 할거면
POST로 전송해야한다.

#6.3
get - 접근
post - 전송
redirect - 다시보내다
parameter - 매개변수
express는 form으로 보낸 데이터를 읽지못함

**
req.body
req.body에는 form을 통해 submit된 데이터의 키-값 쌍을 포함합니다.
기본적으로는 undefined이며 express.json() 또는 express.urlencoded()와 같은 바디 파싱 미들웨어를 사용할 때 값을 받아옵니다.

```
// 애플리케이션/json 파싱
app.use(express.json());
// application/x-www-form-urlencoded파싱 (form데이터 파싱)
app.use(express.urlencoded({ extended: true }));
```
https://expressjs.com/ko/api.html#req.body

express.urlencoded([options])
Express에 내장된 미들웨어 기능입니다. urlencoded 페이로드로 들어오는 요청을 구문 분석하고 바디 파서를 기반으로 합니다.
https://expressjs.com/ko/api.html#express.urlencoded


POST로 보낸 데이터를 사용하려면 req.body로 사용가능하다.
하지만 express는 아직 이걸 이해못한다.
express app이 form의 value를 이해하려면 세팅이필요하다.
server.js에 다음을 추가한다.
app.use(express.urlencoded({ extended: true }));
 => 라우터를 사용하기전에 적용이 돼야한다.

#6.4
POST recap
컨트롤러에서 쓰는 req.params는
 라우터에서 보낸 /:id(//d+)를 가리킨다.
req.body는 pug에서 보낸 form에있는 value의 JavaScript representation이다.
 => 이걸 이용하기위해 server.js에 설정을 해줘야한다.
 => form안의 input에 name을 설정해줘야 req.body안의 데이터를 쓸수있다.
**
GET으로보낸 데이터는 req.query.inputName으로 사용할수있다!

#6.8
mongoose
  자바스크립트 코드로 mongodb를 쓸수있게 해준다
  1)npm i mongoose로 설치
  2)db.js파일에서 import mongoose from "mongoose"
  3)mongoose.connect("mongodb://127.0.0.1:27017/db명");
    =>url주소는 cmd에서 mongo 커맨드 실행시 나오는 주소
그외설정
  const db = mongoose.connection;

  const handleOpen = () => console.log("✅ Connected to DB");
  const handleError = (error) => console.log("❌ DB Error", error);

  db.on("error", handleError);
  db.once("open", handleOpen);
  on => 이벤트발생시 몇번이고 반복함
  once => 이벤트발생시 한번만실행함

#6.9
Video model
 모델 이름은 대문자로 시작한다. Video.js 이게 관습이다.

스키마:물리적인 장치로부터 논리적인 데이터 베이스 레코드(data base record)를
매핑(mapping)하는 데 사용되는 정의 정보를 말한다.

#6.11

Video.find( {}, callback?: )
{} => search terms, 이게 비어있으면 모든 비디오를 찾게된다.

#6.12
database가 javascript 밖에서 수행되다보니(js와 비동기이다)
find({}, ...)가 다른(console.log같은..)것 보다 늦게 수행된다.

database 검색이 안끝났을때 render하는것을 방지하는법
1.
Video.find({}, (error, videos) => {
    
    return res.render("home", { pageTitle: "Home", videos });
  });
Video.find()의 콜백함수((error, videos) =>) 안에 render를 넣는다.

단점 : function안에 function을 넣어서 깔끔하지않아

#6.13

database 검색이 안끝났을때 render하는것을 방지하는법

2. promise => callback의 최신버전
async(비동기) -- await(수행될 때까지 기다려준다)
=> 데이터베이스가 데이터 찾을때까지 기다려준다(다음 것이 먼저 수행되는 것을 막음)
에러는 try-catch문으로 잡는다.

async function
async function 선언은 AsyncFunction객체를 반환하는 하나의 비동기 함수를 정의합니다.
비동기 함수는 이벤트 루프를 통해 비동기적으로 작동하는 함수로, 암시적으로 Promise를 사용하여 결과를 반환합니다.
그러나 비동기 함수를 사용하는 코드의 구문과 구조는, 표준 동기 함수를 사용하는것과 많이 비슷합니다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function

export const home = async (req, res) => {
  const videos = await Video.find({});
  return res.render("home", { pageTitle: "Home", videos });
};
async function선언으로 비동기함수를 선언하고
await를 써서 db에서 데이터를 찾을때까지 기다린다.

장점: 직관적으로 코드를 보기 편하다.

#6.14
1. return의 역할 : 본질적인 return의 역할보다는 function을 마무리짓는 역할로 사용되고 있음.
- 이러한 경우 return이 없어도 정상적으로 동작하지만 실수를 방지하기 위해 return을 사용
2. render한 것은 다시 render할 수 없음
- redirect(), sendStatus(), end() 등등 포함 (express에서 오류 발생)

#6.15
hashtags: hashtags.split(",").map((word) => `#${word}`)
split(",") => 데이터들을 ,로 잘라서 배열로 돌려준다.
map((word) => `#${word}`) =>배열안의 데이터들에게 #를붙인다.

console.log(video)를 하면 우리가 만들지않은 id가 있는데
create video를 할때 mongoose가 id를 자동으로 만들어준다.

#6.16

db에 데이터를 저장하는 두가지방법
1.모델명.create()사용
2.save()사용


MongoDB의 collection이름이 Video가 아닌 videos인 이유
Mongoose는 자동으로 모델을 찾고, 해당 모델의 이름을 따서 소문자+뒤에 s(복수형)을 붙여 컬렉션을 생성합니다.
Tank 모델은 -> 컬렉션에 저장될 때, tanks로 저장됩니다.

Document.prototype.save()
https://mongoosejs.com/docs/api.html#document_Document-save

Model.create()
하나 이상의 문서를 데이터베이스에 저장하기 위한 손쉬운 방법입니다.
MyModel.create(docs)는 문서의 모든 문서에 대해 새로운 MyModel(doc).save()를 수행합니다.
create()을 하게 되면 save()를 생략할 수 있습니다.
create()이 다음 미들웨어인 save()를 트리거하기 때문입니다.
https://mongoosejs.com/docs/api.html#model_Model.create

Collection: Document들을 담고 있는 묶음

#6.17
Exception & validation
1. try/catch를 통한 에러처리, 에러메세지 전달
2. Schema parameter : default
3. Schema CreatedAt에 Date.now()가 아닌 Date.now를 적는 이유 : 생성될때만 실행되도록
 =>videoSchema 에서 default: Date.now() 라고 하면 그 schema가 있는 파일을 저장하는 시간이 default 로 저장댐

#6.18
More Schema (몽구스 스키마)
몽구스 스키마 타입 확인
Mongoose 스키마는 Mongoose 모델을 구성하기 위한 객체로 생각할 수 있습니다.
https://mongoosejs.com/docs/schematypes.html

몽구스 스키마 타입 정의
몽구스의 모든 것은 스키마로 시작합니다. 각 스키마는 MongoDB 컬렉션에 매핑되고 해당 컬렉션 내 문서의 모양을 정의합니다.
https://mongoosejs.com/docs/guide.html

#6.19
정규식 regular expression
1. mongoose가 부여한 id를 사용하기 위해 id에 숫자만 사용가능하게 설정한 Router부분 변경
- http://regexpal.com 을 통한 정규식 생성하기
2. id를 통해 db 내 색인, 해당 데이터 사용하기

#6.20
Edit Video
1. .exec()에 대한 간략한 설명
2. 사용자가 존재하지 않는 ID에 접근할 경우 => if {404.pug}
3. 일반적으로 에러를 if에 처리, return으로 함수 종료
4. join()으로 배열을 문자열로 통합

#6.21
1. post 복습
2. postEdit 구현, 일일히 수정 => 안 즐겁다
3. startWith()로 # 유무 확인
4. 조건부 연산자 ?를 통한 간결한 조건문

String.prototype.startsWith()
startsWith() 메소드는 어떤 문자열이 특정 문자로 시작하는지 확인하여
결과를 true 혹은 false로 반환합니다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

String.prototype.endsWith()
The endsWith() 메서드를 사용하여 어떤 문자열에서 특정 문자열로 끝나는지를 확인할 수 있으며,
그 결과를 true 혹은 false로 반환한다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

#6.22
Edit part three
1. Model.findByIdAndUpdate()로 불러오기와 수정 한방에 => 즐겁다
2. Model.exist() =>true false 반환
3. 생성이나 업데이트 전 작동해야할 function의 필요성 => Mongoose의 Middleware 활용

#6.23
1. DeprecationWarning에 대해.. useFindAndModify: false로 설정하면 해결됨
2. middleware는 무조건 model이 생성되기 전에 만들어야 한다
3. mongoose의 middleware에서 this키워드는 저장하고자 하는 문서를 가리킴
4. middleware에서 해시태그 관리 구현

cmd 커맨드
1. 몽고 사용하기
> mongo

2. 내가 가진 db 보기
> show dbs

3. 현재 사용 중인 db 확인
> db

4. 사용할 db 선택하기
> use dbName
(현재 수업에서는 `use wetube`)

5. db 컬렉션 보기
> show collections

6. db 컬렉션 안에 documents 보기
> db.collectionName.find()
(현재 수업에서는 `db.videos.find()`)

7. db 컬렉션 안에 documents 내용 모두 제거하기
> db.collectionName.remove({})
(현재 수업에서는 `db.videos.remove({})`)

#6.24
Static function(스태틱 함수)
1. findByIdAndUpdate()에서는 save 훅업이 발생하지 않음 => 다른 방법을 알아보자
2. Video.js에 function을 만들어서 epxort해서 관리하기 => 이것도 괜찮음 근데 다른것도 알아보자
3. static을 사용하면 import 없이도 Model.function()형태로 사용이 가능함 => super cool

Statics
모델에 static 함수를 추가할 수도 있습니다.
스키마에서 컴파일된 모델에 정적 "class" 메서드를 추가합니다.

Static 사용하는 두 가지 방법
```
// Assign a function to the "statics" object of our animalSchema
animalSchema.statics.findByName = function(name) {
return this.find({ name: new RegExp(name, 'i') });
};
// Or, equivalently, you can call `animalSchema.static()`.
animalSchema.static('findByBreed', function(breed) { return this.find({ breed }); });
```
https://mongoosejs.com/docs/guide.html#statics

#6.25
delete

1. Delete Video 구현
2. Delete는 Remove를 대체하며 충분한 이유가 있지 않은 이상 Delete를 사용

Model.findOneAndDelete()
Model.findOneAndRemove()

이 둘은 정말 약간의 차이가 있는데 대부분의 상황에서 타당한 이유가 없는 한
delete를 사용하라고 되어 있음.
https://www.zerocho.com/category/MongoDB/post/579ecb1fc097d015000404dd

여기 글을 읽어보니 몽고 db는 롤백이 안되서 remove를 하면 다시 되돌릴 수 없기에
remove보다 delete를 사용하라고 권장하는듯

#6.26
Search
1. Model.sort()로 정렬 방식 변경
2. Search 구현
3. get 메소드에서 form 값을 가져오기 위해서는 req.query 이용

Query.prototype.sort()
정렬 순서를 설정합니다. 개체가 전달되면 허용되는 값은 asc, desc, 오름차순, 내림차순, 1 및 -1입니다.
https://mongoosejs.com/docs/api.html#query_Query-sort

req.query
라우트 안에 query string parameter를 포함하고 있는 객체로, URL에서 데이터를 가져올 때 주로 사용한다.
예) ?keyword="food" => {keyword: "food"}
query parse가 비활성화로 설정되면 빈 객체 {}이고, 그렇지 않으면 구성된 query parse의 결과입니다.
https://expressjs.com/ko/api.html#req.query

#6.27
Search
1. Model.find()를 통한 Search
2. 오퍼레이터를 통한 Model.find()의 고도화 (mongoDB)
  =>정규식을 통해서 search기능을 정교하게.

Model.find()
documents를 찾습니다. (findOne과 다르게 전체 document를 찾습니다.)
Mongoose는 명령이 전송되기 전에 모델의 스키마와 일치하도록 필터를 캐스팅합니다.
https://mongoosejs.com/docs/api.html#model_Model.find

정규표현식
https://www.regexpal.com

몽고DB regex ($regex)
몽고DB에서 정규표현식을 사용하기 위해 사용하는 키워드
쿼리의 패턴 일치 문자열에 대한 정규식 기능을 제공합니다.
https://docs.mongodb.com/manual/reference/operator/query/regex

RegExp mdn
RegExp 생성자는 패턴을 사용해 텍스트를 판별할 때 사용합니다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp

RegExp 사용 방법
RegExp 객체는 리터럴 표기법과 생성자로써 생성할 수 있습니다.
리터럴 표기법의 매개변수는 두 빗금으로 감싸야 하며 따옴표를 사용하지 않습니다.
생성자 함수의 매개변수는 빗금으로 감싸지 않으나 따옴표를 사용합니다.
```
/ab+c/i 를 아래 RegExp 생성자를 이용해서 만들 수 있습니다.
new RegExp(/ab+c/, 'i') // 리터럴 표기법
new RegExp('ab+c', 'i') // 생성자 함수

#7.0
Create User model.

#7.2
hash password 해시화
해싱 ->입력값을넣으면 출력값이 나온다
 => 출력값으로 입력값을 얻지못한다.
 => 같은입력값으로 항상 같은 출력값이나온다
npm i bcrypt 으로 설치한다.
모델의 pre(save)기능을 이용해 db에 저장하기전에 해싱한다.
userSchema.pre("save", async function () {
  this.password = await bcrypt.hash(this.password, 5);
});
this는 유저가 입력한 데이터를 말한다.
saltRounds => 몇번 해싱할것인지 정하는

해시를 이용해 해킹공격하는 rainbow table이있는데, bcrypt에서 막아줄것이다.

#7.3
Form Validation

$or
$or 연산자는 둘 이상의 조건에 대해 논리적 OR 연산을 수행하고 조건 중 하나 이상을 충족하는 문서를 선택합니다.

// 예시
```
db.inventory.find( { $or: [ { quantity: { $lt: 20 } }, { price: 10 } ] } )

```
https://docs.mongodb.com/manual/reference/operator/query/or/#mongodb-query-op.-or

#7.4
Status Codes
Status Codes 400을 렌더링할때 같이 보내주면
브라우저가 방문 목록을 저장할때 하지않는다.

상태코드
- 200(OK): 서버가 요청을 제대로 처리했다는 뜻이다. 이는 주로 서버가 요청한 페이지를 제공했다는 의미로 쓰인다.
- 400(Bad Request): 서버가 요청의 구문을 인식하지 못할 때 발생한다. 클라이언트 측에서 문제가 있을 때 주로 발생한다.
- 404(Not Found): 서버가 요청한 페이지를 찾을 수 없을 때 발생한다. 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 제공한다.
https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C

res.status(code)
response에 대한 HTTP 상태를 설정합니다. (status를 설정한다.)
https://expressjs.com/ko/api.html#res.status
https://nodejs.org/api/http.html#http_response_statuscode

#7.6
compare hash password 
bcrypt를 이용해서 비밀번호 비교

password: 유저가 입력한 비밀번호
user.passwordHash: DB에 해시화되서 저장된 비밀번호
```
const match = await bcrypt.compare(password, user.passwordHash);
```
https://www.npmjs.com/package/bcrypt

#7.7
session

npm i express-session

1. 브라우져 서버에 접근
2. 서버가 브라우져에게 쿠키(세션id)를 준다.
3. 브라우져가 서버에 다시 접근할 때 2.에서 받은 쿠키(세션id)를 함께 건냄.
4. 서버는 쿠키(세션id)를 통해 브라우져를 구분 할 수 있다.

세션은 오브젝트라 우리가 정보를 붙일수있다.
ex) req.session.user = user;
...
즉 유저를 로그인시키는것은 우리가 req.session 오브젝트 안에
정보를 넣는 것이다.

express-session
Express용 세션 미들웨어
세션 데이터는 쿠키 자체에 저장되지 않고 세션 ID에만 저장됩니다. 세션 데이터는 서버 측에 저장됩니다.
npm i express-session
https://www.npmjs.com/package/express-session

Session 사용 예시
https://github.com/expressjs/session#example

req.session.id 또는 req.sessionID
브라우저가 request할 때 같이 보내는 session id

resave (변경 사항이 없어도 저장)
request하는 동안 세션이 수정되지 않은 경우에도 세션이 세션 저장소에 다시 저장되도록 합니다.
https://github.com/expressjs/session#resave

saveUninitialized (세션 초기화 전에도 저장)
"초기화되지 않은" 세션을 저장소에 강제로 저장합니다.
https://github.com/expressjs/session#saveuninitialized

#7.8
세션 part2

세션은 서버측에서 제공해주는 데이터, 쿠키는 클라이언트측에서 저장하고 사용하는 데이터
  req.sessiontStore() 사용했을때 한번은 undefined가 나온 이유가
  세션은 서버에서 만들어줘야 하는데 클라이언트가 첫 요청때 세션을 가지고있을리 없으니
  undefined이 나온거고 그 이후 요청부턴 첫번째 요청때 세션을 만들어서 넘겨줬으니
  클라이언트가 해당 값을 쿠키에 저장하고 매 요청때마다 서버에게 전달
세션은 서버가 만들어서 제공해주다보니 서버가 재부팅되면 초기화 된다.
  => (그래서 DB에 저장해서 관리를 한다는 소리. 실 운영에선 서버가 꺼지는 일은 없으니깐.)
세션의 값은 서버가 만들어주는 고유값이다보니 해당 값을 기준으로 클라이언트에서 요청한 건에 대해 유저를 특정지을 수 있다
  ==>서버가 세션을 생성한 기점은 middleware로 express-session을 추가했을때부터 생성됨.

====>>
즉, 브라우져에서 서버에 로그인 요청을 해서 로그인이 되면 서버는 세션id를 response해주고
브라우져는 쿠키스토리지에 그 세션id를 보관하고 있다가 이후 다시 서버에 방문할 시에는 그 세션
id만 보여주면 자동으로 로그인되게 해줘서 계속 로그인할 수고를 덜어준다는 것이겠군요.

#7.9~10
res.locals 는 전역번수 오브젝트이다.
pug에서는 session을 바로 읽지못하지만, locals는 읽을수있다.

res.locals

request 범위가 지정된 response 로컬 변수를 포함하는 객체이므로 request, response 주기동안 렌더링된 view에서만 사용할 수 있습니다.
(Pug나 EJS같은 템플릿 엔진에서 사용 가능하다는 의미)
이 속성은 request path, 인증된 사용자, 사용자 설정 등과 같은 request level의 정보를 노출하는 데 유용합니다.
```
// 사용 예시
app.use(function (req, res, next) {
res.locals.user = req.user
res.locals.authenticated = !req.user.anonymous
next()
})
```
https://expressjs.com/ko/api.html#res.locals

#7.12
MongoStore

세션
세션id는 쿠키에 저장돼지만 세션데이터는 서버사이드에 저장됀다.
디폴트로 지정된 서버사이드 스토리지는MemoryStore이다.
 => 서버 메모리에 저장돼기 때문에 서버를 재시작 할때마다 메모리가 지워진다.
 =>그래서 session store(데이터베이스)에 세션을 저장해야한다.

MongoDB의 경우 connect-mongo를 사용한다. => npm i connect-mongo
=>세션을 mongodb에 저장한다.

#7.13
Uninitialized Sessions
방문한 모든 사람, 로그인하지않은사람, 봇의 session을 저장하는게 좋을까?
 =>로그인한사람의 세션만을 저장하는것이 좋다.

**
DB 미들웨어에서
resave: request에서 새로 생성된 session과 기존에 있던 session이 똑같을 때에도 다시 저장할 것인가?
-> 대부분의 경우 false, 공식문서에서도 false를 권장하며 true는 deprecated 상태

saveUninitialized : true
 => 따로 값을 설정하지 않은 전달 받은 날것의 세션을 즉시 Store에 저장 후 세션 주인에게 쿠키를 (답장하듯) 넘겨 준다.

saveUninitialized : false
  => req.session 속 값을 수정하는 그 순간에(session.user=user) 세션을 Store에 저장 후 그제야 쿠키를 전달한다.
  => 세션을 수정하는 행위 자체가 initialize(초기화)하는것이다.
  => 즉 로그인할때 세션에 데이터를 저장하는행위에서만 DB에 세션저장이 됀다.

#7.14
Expiration and Secrets

1. .env 파일 만들기
2. env 파일을 .gitignore에 추가하기. (git에 업로드 하지 않기 위해)
3. 비밀로 해야 하는 string을 process.env.[환경변수이름]으로 바꾸기


Set-Cookie
Set-Cookie HTTP 응답 헤더는 서버에서 사용자 브라우저에 쿠키를 전송하기 위해 사용됩니다.
https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie

쿠키에 설정가능한 옵션
Domain
쿠키가 적용되어야 하는 호스트를 지정.

Expires
HTTP 타임스템프로 기록된 쿠키의 최대 생존 시간(수명).

Max-Age
쿠키가 만료될 때 까지의 시간 (밀리세컨드)

secret
이것은 세션 ID 쿠키에 서명하는 데 사용되는 비밀입니다.
https://www.npmjs.com/package/express-session

COOKIE_SECRET에 넣을 랜덤 문자열 생성 사이트
https://randomkeygen.com/

#7.15
Environment Variables 환경변수

dotenv
Dotenv는 .env 파일에서 process.env로 환경 변수를 로드하는 제로 종속성 모듈입니다.
npm i dotenv

프로젝트에서 될수있는한 가장먼저 dotenv를 import해줘야한다.
 => 이번프로젝트는 init.js가 가장빠르다.
 =>import방법은 두가지있다.
 =>방법1. require(dotenv가필요한 모든파일에)
    방법2. import "dotenv/config"
https://www.npmjs.com/package/dotenv


#7.16
Github Login

1.사용자를 github로 보낸다.
2.사용자가 github로그인하고, github는 유저를 웹사이트로 redirect시킨다(토큰,유저 정보랑같이)
3.토큰을 이용하여 유저정보를 얻는다.


https://github.com/login/oauth/authorize?client_id=입력값&allow_signup=false

Authorizing OAuth Apps
다른 사용자가 OAuth 앱을 승인하도록 할 수 있습니다.
GitHub의 OAuth 구현은 웹 브라우저에 대한 액세스 권한이 없는 앱에 대한 표준 인증 코드 부여 유형 및 OAuth 2.0 장치 인증 부여를 지원합니다.

Web application flow
웹 애플리케이션 흐름: 브라우저에서 실행되는 표준 OAuth 앱에 대해 사용자에게 권한을 부여하는 데 사용됩니다.
앱 사용자에게 권한을 부여하는 웹 애플리케이션 흐름은 다음과 같습니다.
1. 로그인하려는 사이트에서 유저의 GitHub identity를 request하기 위해 유저를 GitHub 페이지로 리다이렉트시킵니다.
2. 유저는 리다이렉트된 GitHub에서 승인을 하고, GitHub에 의해 다시 로그인하려는 사이트로 리다이렉트됩니다.
3. 로그인 하려는 사이트는 유저의 액세스 토큰을 통해 API에 접근합니다.
https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps

깃허브 OAuth Apps Setting
GitHub API를 사용하기 위해 등록한 애플리케이션입니다.
https://github.com/settings/developers

Scopes for OAuth Apps (OAuth 앱의 범위)
https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps

Creating an OAuth App (OAuth앱 만들기)
https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app

#7.17

긴 URL은 그대로 쓰는게아니라, 변수를만들어 관리하자.


&scope=read:user
&scope=read:user user:email

Scopes for OAuth Apps
OAuth 앱은 초기 리디렉션에서 범위를 요청할 수 있습니다. %20을 사용하여 공백으로 구분하여 여러 범위를 지정할 수 있습니다.
// 사용 예시
```
https://github.com/login/oauth/authorize?client_id=...&scope=user%20repo_deployment
```
https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps

URLSearchParams
URLSearchParams 인터페이스는 URL의 쿼리 문자열에 대해 작업할 수 있는 유틸리티 메서드를 정의합니다.
https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams

URLSearchParams.toString()
toString() 은 URLSearchParams 인터페이스의 메소드로서, URL에서 사용할 수 있는 쿼리 문자열을 리턴합니다.
https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams/toString

https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps

#7.18

깃허브에서 보내준 코드로 access_token이란것을 받아야하는데,
그를위해 POST Request를 보내야한다.
POST reqeust를 보내는데는, fetch()를 쓰면 좋은데(), 서버에는 없고 브라우저에만 있는 기능이다.
 =>node-fetch라는 패키지로 쓸수있다.

Users are redirected back to your site by GitHub

사용자가 요청을 수락하면 GitHub는 코드 매개변수의 임시 code와 상태 매개변수의 이전 단계에서 제공한 state를 사용하여 사이트로 다시 리디렉션합니다.

POST Request를 할 때, 반드시 필요한 파라미터들
client_id, client_secret, code
```
POST https://github.com/login/oauth/access_token
```
https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps#2-users-are-redirected-back-to-your-site-by-github

#7.19
node-fetch
JS와 NodeJS는 다른 플랫폼이기때문에 fetch를 쓰려면 node-fetch를 써야한다.
npm i node-fetch

github에서 받은 코드로 access_token을 얻을수있는데, GitHub API를 이용해 user 정보를 얻을수있다.

[2022.01.24] HTTP headers (fetch의 header의 역할)

HTTP headers는 는 클라이언트와 서버가 request(or response)로 부가적인 정보를 전송할 수 있도록 해줍니다

Accept
돌려줄 데이터 타입에 대해 서버에게 알려주는 역할을 합니다
MIME 타입입니다
(📌MIME type이란 웹에서 사용되는 확장자라고 생각하시면 되며
type/subtype으로 구성되어 있습니다)

Authorization
보호된 리소스에 대한 접근을 허용하여 서버로 User agent를 인증하는 자격증명을 보내는 역할을 합니다

[출처]
HTTP headers: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers
MIME tyeps: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types

****
Error [ERR_REQUIRE_ESM]: require() of ES Module 오류 발생 시 두 가지 방법 중 하나로 해결할 수 있습니다.

1. node-fetch 3버전이 아닌 2버전으로 다운그레이드된 버전을 설치해서 해결할 수 있습니다.
npm i node-fetch@2.6.1 (강의과 같은 버전)
https://www.npmjs.com/package/node-fetch

2. cross-fetch 사용 (CommonJS, ES6 모듈, Typescript등에서도 사용가능)
node-fetch대신 사용할 수 있는 cross-fetch 패키지를 통해 해결할 수 있습니다. node-fetch와 사용법은 동일합니다.
Node, 브라우저 및 React Native용 범용 WHATWG Fetch API.
npm i cross-fetch
```
import fetch from 'cross-fetch';

fetch(...)
```
https://www.npmjs.com/package/cross-fetch

node-fetch 버전3 문제
v3의 node-fetch는 ESM 전용 모듈입니다. require()로 가져올 수 없습니다. ESM으로 전환할 수 없는 경우 CommonJS와 호환되는 v2를 사용하십시오. 중요한 버그 수정은 v2에 대해 계속 게시됩니다.

Use the access token to access the API
액세스 토큰을 사용하면 유저를 대신해 API에 요청할 수 있습니다.
```
Authorization: token OAUTH-TOKEN
GET https://api.github.com/user
```
https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps#3-use-the-access-token-to-access-the-api
****

#7.20

Github REST API (User)
사용자 API를 사용하면 인증된 사용자에 대한 공개 및 비공개 정보를 얻을 수 있습니다.
https://docs.github.com/en/rest/reference/users

Get the authenticated user
인증된 사용자가 기본 인증 또는 사용자 범위의 OAuth를 통해 인증되면 응답에 공개 및 비공개 프로필 정보가 나열됩니다. 인증된 사용자가 사용자 범위 없이 OAuth를 통해 인증된 경우 응답에는 공개 프로필 정보만 나열됩니다.

Add an email address for the authenticated user
https://docs.github.com/en/rest/reference/users#add-an-email-address-for-the-authenticated-user

List public email addresses for the authenticated user
인증된 사용자의 공개 이메일 주소 나열
https://docs.github.com/en/rest/reference/users#list-public-email-addresses-for-the-authenticated-user

#7.21
로그인 규칙을 어떻게 만들것인가?
=>깃허브 email이 verified, primary이고, DB에 똑같은 email이 있으면 로그인시킨다.
=> DB에 일치하는 데이터가없으면, 깃허브 유저정보를 이용해 유저를 생성시키고, 로그인시킨다.

#7.22

로그아웃

Session.destroy(callback)

세션을 파괴하고 req.session 속성을 설정 해제합니다. 완료되면 콜백이 호출됩니다.
```
req.session.destroy(function(err) {
// cannot access session here
})
```
https://www.npmjs.com/package/express-session

#7.23

카카오 로그인 구현하기 (REST API)
카카오 로그인 구현하실 분들은 아래 링크들을 참조하시면 됩니다.
구현 방식은 깃허브 로그인과 거의 동일합니다.
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api

0. 애플리케이션 등록
https://developers.kakao.com/docs/latest/ko/getting-started/app

1. 인가 코드 받기
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#request-code

2. 토큰 받기
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#request-token

3. 사용자 정보 가져오기
https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#req-user-info

#8.0
Edit Profile

로그인하지 않은 유저는 edit페이지에 접근할수 없어야한다.
 =>로그인하지않았다면, middlewares.js에서 lcoals의 user오브젝트는 정의돼지 않으므로,
  에러가 난다.
  =>로그인하지 않았다면 빈 오브젝트를 돌려주어 일단 에러는 막는다.res.locals.loggedInUser = req.session.user || {};

#8.1

Protector and Public Middlewares

각 페이지마다 접근 가능한 사람을 제한해야 한다.
=>middleware를 추가하여 각 라우터에 용도에 맞게 붙혀준다.
=>all()함수는 get.post둘다있는 라우터에 둘다 적용할수있게 해준다.

#8.2

edit Profile
POST로 입력값을 받아와서 업데이트를 하면
DB값은 업데이트돼지만, 세션은 업데이트돼지 않는다.
세션도 업데이트를 해줘야 바뀐 값이 반영됀 user 오브젝트가
세션에 들어가게 됀다.

Model.findByIdAndUpdate()

문서의 _id 필드로 mongodb findAndModify 업데이트 명령을 실행합니다. findByIdAndUpdate(id, ...)는 findOneAndUpdate({ _id: id }, ...)와 동일합니다.

```
// 사용 예시
Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options, callback)

// is sent as (+타입스크립트)
Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options, callback)
```
https://mongoosejs.com/docs/api.html#model_Model.findByIdAndUpdate